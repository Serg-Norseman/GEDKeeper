<!DOCTYPE html>
<html lang="ru">
<head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
    <title>Справка GEDKeeper. Использование скриптов</title>
    <link rel="stylesheet" href="../help/styles.css" type="text/css">
</head>
<body>

    <h1>Оглавление</h1>
    <ul>
        <li><a href="#1">1 - Введение в Lua</a></li>
        <li><a href="#2">2 – Описание языка Lua</a></li>
        <li><a href="#3">3 - Использование Lua в программе GEDKeeper</a></li>
    </ul>

    <h1><a id="1">1 - Введение в Lua</a></h1>

    <p>
        Lua является типичным процедурным языком программирования, предоставляющим широкие возможности для разработки.
        Это мощный и простой язык, обладающий всеми необходимыми выразительными средствами.
    </p>

    <p>
        Будучи языком для создания расширений, Lua не имеет понятия основной программы,
        он работает в среде исполнения других программ, сокращенно называемых <b>хост-программами</b>.
        В данном случае хост-программой является программа GEDKeeper. Хост-программа позволяет
        запускать части кода (далее скрипты), написанные на Lua. Благодаря возможности расширения функциями хост-программы, Lua может
        применяться для решения широкого круга задач.
    </p>

    <p>
        Lua является свободно распространяемым программным средством, поэтому предоставляется без каких-либо гарантий в соответствии с лицензией.
        Версия <b>lua 5.1</b>, которая описана в данном Руководстве, доступна на официальном сайте Lua <b>www.lua.org</b>.
    </p>

    <p>
        Как и многие подобные Руководства, этот документ написан в формальном стиле. Для получения более подробной информации об особенностях применения языка
        рекомендуем обратиться к технической документации, доступной на официальном сайте Lua. Хорошим подспорьем в работе может оказаться книга Роберта Иерусалимского (Roberto Ierusalimschy)
        «Программирование на Lua», второе издание <em>(Programming in Lua (Second Edition))</em>.
    </p>

    <h1><a id="2">2 – Описание языка Lua</a></h1>

    <p>В этой главе описываются элементы языка, способы их комбинирования и значение языковых конструкций.</p>

    <p>
        Конструкции языка будут вводится с использованием расширенной BNF, где запись {<em>a</em>} означает 0 или более элементов <em>a</em>,
        а запись [<em>a</em>] означает его необязательное вхождение. Нетерминальные символы отображаются обычным шрифтом, ключевые слова
        выделяются жирным шрифтом <b>kword</b>, все остальные терминальные символы заключаются в апострофы `<b>=</b>?.
    </p>


    <h2><a id="2.1">2.1 – Лексические соглашения</a></h2>

    <p>
        <em>Именами</em> (<i>идентификаторами</i>) в Lua могут быть любые строки из букв, цифр и символа подчеркивания, не начинающиеся с
        цифры. Это правило типично для большинства языков программирования. Идентификаторы используются для именования переменных и таблиц значений.
    </p>

    <p>Следующие <i>ключевые слова </i>зарезервированы и не могут быть использованы в именах:</p>

    <div class="contdiv">
        <pre><code class="lua">
and      break    do	 else       elseif
end      false    for    function   if
in       local    nill   not        or
repeat   return   then   true       until   while
</code></pre>
    </div>

    <p>
        Lua является языком, чувствительным к регистру символов: and – ключевое слово, тогда как And и AND – два разных допустимых идентификатора. По соглашению, имена,
        начинающиеся с символа подчеркивания и записанные в верхнем регистре (например, _VERSION), зарезервированы для использования в качестве внутренних глобальных переменных,
        используемых Lua.
    </p>

    <p>В следующих строках показаны другие допустимые символы:</p>

    <div class="contdiv">
        <pre><code class="lua">
+   *   /   %   ^   &#47;   #
==   ~=   &lt;=   &gt;=   &lt;   &gt;   =
(   )   {   }   [   ]
;   :   ,   .    ..   ...
</code></pre>
    </div>

    <p>
        <em>Литеральные строки </em><em>должны быть заключены в одинарные или двойные кавычки и</em> могут
        содержать следующие С-подобные escape-последовательности:
        '\a' («звонок»), '\b' («забой»), '\f' («перевод страницы»),
        '\n' («перевод на новую строку»), '\r' («возврат каретки»),
        '\t' («горизонтальная табуляция»), '\v' («вертикальная табуляция»),
        '\\\&quot;' («двойная кавычка»), and'\'' (апостроф [«одинарная кавычка»]). Кроме
        того, обратный слеш ставится перед концом строки в редакторе, когда для
        удобства набора длинные непрерывные строки записываются в несколько строк. Символ
        в строке также может быть представлен своим кодом с помощью escape-последовательности \<em>ddd</em>, где <em>ddd</em>-
        последовательность из не более чем трех цифр. (Заметим, что если после символа,
        записанного с помощью своего кода, должна идти цифра, то код символа в escape-последовательности
        должен содержать ровно три цифры). Строки в Lua могут содержать любые 8-битные
        значения, включая ноль, который записывается как '\0'.
    </p>

    <p>
        Чтобы поместить одни двойные кавычки, символы новой строки, обратный слэш, или нулевой символ в строку, ограниченную двойными кавычками вы
        должны использовать escape-последовательности. Любой другой символ может быть напрямую включен в строку.
    </p>

    <p>
        Символьные строки могут также определяться используя длинный формат, ограниченный <em>длинными скобками</em>.
        Мы определяем <em>открывающую длинную скобку уровня n</em> как открывающую квадратную скобку следующую за <em>n</em>
        знаками равенства следующими за другой открывающей квадратной скобкой. Так, открывающая длинная скобка уровня &nbsp;0
        записывается как [[, открывающая длинная скобка уровня &nbsp;1 записывается как [=[, и так далее.
        <em>Закрывающая длинная скобка</em> определяется также; для примера, закрывающая скобка уровня &nbsp;4
        записывается как ]====]. Длинные строки начинаются с
        открывающей длинной скобки любого уровня и заканчиваются первой закрывающей длинной скобкой
        соответствующего уровня. Литералы в такой форме могут находится в разных строках, escape-последовательности
        не интерпретируются, и игнорируются длинные скобки любого другого уровня.
        Они могут содержать что угодно, исключая закрывающую скобку соответствующего уровня.
    </p>

    <p>
        Для удобства, когда открывающая длинная скобка следует непосредственно в новой линии,
        эта линия не включается в строку. Для примера, в системе использующей ASCII (в которой 'a' кодируется как&nbsp;97,
        новая строка как&nbsp;10, и '1' как&nbsp;49), пять литералов ниже обозначают одну строку:
    </p>

    <div class="contdiv">
<pre>     a <span class="S10">= '</span> alo<span class="S10">\</span>n123&quot;<span class="S10">'</span></pre><pre>     a <span class="S10">=</span> &quot;alo<span class="S10">\</span>n123<span class="S10">\</span>&quot;&quot;</pre><pre>     a <span class="S10">=</span> '<span class="S10">\</span>97lo<span class="S10">\</span>10<span class="S10">\</span>04923&quot;'</pre><pre>     a <span class="S10">= [[</span>alo</pre><pre>     123&quot;<span class="S10">]]</span></pre><pre>     a <span class="S10">= [==[</span></pre><pre>     alo></pre><pre>     123&quot;<span class="S10">]==]</span></pre>
    </div>

    <p>
        <em>Числовая константа</em> может быть записана с опциональной десятичной частью
        и опциональной десятичной экспонентой. Lua также принимает целый шестнадцатеричные константы, с префиксом 0x.
        Примеры правильных числовых констант
    </p>

<pre>&lt;o:p&gt;&nbsp;&lt;/o:p&gt;</pre><pre>     3   3.0   3.1416   314.16e-2   0.31416E1   0xff   0x56</pre>

    <p>
        <em>Комментарий</em> начинается с двойного дефиса (--) везде за пределами строки. Если текст непосредственно после -- не содержит длинную открывающую скобку [,
        комментарий является <em>коротким</em>, который продолжается до конца строки. Иначе, это <em>длинный комментарий</em>, который продолжается пока не встретится
        закрывающая длинная скобка ]. Длинный комментарий часто встречается для временной деактивации кода.
    </p>


    <h2><a id="2.2">2.2 – Значения и типы</a></h2>

    <p>
        Lua представляет собой язык с <i>динамическим определением типов данных</i>. Переменная языка может содержать значения любого типа.
        Возможности определения пользовательских типов данных отсутствуют. Все значения в Lua могут храниться в переменных, использоваться в качестве аргументов при вызове функций
        и возвращаться в виде результата их выполнения.
    </p>

    <p>
        В Lua восемь основных типов: <em>nil (неопределенный)</em>, <em>boolean (логический)</em>,
        <em>number (числовой)</em>, <em>string (строковый)</em>, <em>function (функция)</em>,
        <em>userdata (пользовательские данные)</em>, <em>thread (поток)</em>, и <em>table (таблица)</em>.

        <em>Nil - </em>это тип значения <b>nil [пустое значение]</b>, главное свойство
        которого – отличаться от всех остальных значений и обозначать отсутствие
        пригодного значения. К типу <em>Boolean</em> относятся значения <b>false</b> (ложь) и <b>true </b>(истина). Значения <b>nil</b> и
        <b>false</b> считаются ложными, любое другое значение считается истинным.
        К типу <em>Number</em> относятся вещественные числа (двойной точности с плавающей запятой).
        Тип <em>String </em><em>обозначает</em> массивы символов. Строки Lua могут содержать
        любые 8 битные символы, включая ноль ('\0') (см. <a href="#2.1">§2.1</a>).
    </p>

    <p>В Lua можно использовать функции, написанные на Lua или предоставляемые хост-программой (см. <a href="#2.5.8">§2.5.8</a>).</p>

    <p>
        Тип <em>userdata (пользовательские данные) </em> позволяет хранить любые данных из хост-программы в переменных Lua. Значение этого типа является
        ссылкой на блок физической памяти и не имеет предопределенных операций в Lua, за исключением
        присваивания и проверки на равенство. Однако, используя <em>метатаблицы</em>, программист
        может определить операции над значениями этого типа (см. <a href="#2.8">§2.8</a>).
        Значения типа userdata не могут быть созданы или изменены непосредственно в Lua, это возможно только
        с помощью хост-программе. Такой подход гарантирует целостность данных, принадлежащих ведущей программе.
    </p>

    <p>
        Тип <em>table (таблица)</em> определяет ассоциативные массивы. Такие массивы могут индексироваться не только числами, но и любыми значениями (за
        исключением <b>nil</b>). Таблица может содержать значения сразу нескольких типов (кроме <b>nil</b>). Таблицы представляют собой единственный механизм
        структурирования данных в Lua;  они могут использоваться как простые массивы, таблицы символов, множества, поля записей, деревья и так далее. Для представления словарей Lua использует
        имя поля в качестве индекса таблицы. Представление в виде a.name считается тождественным представлению a[&quot;name&quot;]. В Lua есть несколько
        способов создания таблиц (см. <a href="#2.5.7">§2.5.7</a>).
    </p>

    <p>
        Индексы и значения полей таблицы могут быть любого типа (кроме <b>nil</b>). В частности, так как функции являются значениями встроенного типа, поля таблицы могут содержать и
        функции. Таким образом, таблицы могут хранить методы <em>methods</em> (см. <a href="#2.5.9">§2.5.9</a>).
    </p>

    <p>
        Переменные типа <i>table</i>, <i>function</i>, <i>thread</i> и <i>userdata</i> не
        содержат самих данных, в них хранятся только ссылки на соответствующий объект. Присваивание,
        передача параметров и возврат результата из функции оперируют только ссылками
        на значения, эти операции никогда не ведут к созданию копий.
    </p>

    <p>Библиотечная функция <i>type</i> возвращает строку, описывающую тип данного значения.</p>


    <h3><a id="2.2.1">2.2.1 – Приведение типов</a></h3>

    <p>
        Lua обеспечивает автоматическое преобразование между строковыми и числовыми значениями в процессе выполнения. Любая арифметическая операция, применяемая к строке, пытается
        преобразовать эту строку в соответствующее число по обычным правилам приведения. Когда же число используется там, где ожидается строка, это число преобразуется в
        строку в произвольном подходящем формате. Так что для получения какого-то конкретного представления числа в строке необходимо использовать функцию
        <span style='font-size:10.0pt;'>format</span> из библиотеки работы со строками (см. <a href="#pdf-string.format">
            <span style='font-size:10.0pt;'> string</span><span style='font-size:10.0pt'>.</span><span lang="en-us" style='font-size:10.0pt;'>format</span>
        </a>).
    </p>


    <h2><a id="2.3">2.3 - Переменные</a></h2>

    <p>Переменные используются для хранения значений в процессе выполнения программы. В Lua есть три вида переменных: глобальные, локальные и поля таблиц.</p>

    <p>Отдельный идентификатор может обозначать глобальную или локальную переменную (либо формальный параметр функции, что является частным случаем локальной переменной) :</p>

    <div class="contdiv">
        <pre><code class="lua">
var ::= Name Имя
</code></pre>
    </div>

    <p>Где Name – идентификатор, определяемый в соответствии с <a href="#2.1">§2.1</a>.</p>

    <p>
        Любая переменная считается глобальной, если она явно не объявлена как локальная (см. <a href="#2.4.7">§2.4.7</a>). Локальные переменные
        существуют в лексическом контексте: локальные переменные доступны функциям, определенным внутри этого контекста (см. <a href="#2.6">§2.6</a>).
    </p>

    <p>До первого явного присвоения значением переменной является <b>nil</b>.</p>

    <p>Квадратные скобки используются для доступа к элементу таблицы по индексу:</p>

    <div class="contdiv">
        <pre><code class="lua">
var ::= prefixexp '[' exp ']'
</code></pre>
    </div>

    <p>
        Способ доступа к глобальным переменным и полям таблицы может быть изменен с помощью мететаблиц. Доступ к переменной t[i] эквивалентен вызову gettable_event(t,i).
        (Полное описание функции gettable_event смотрите в <a href="#2.8">§2.8</a>. Эта функция недоступна в коде Lua, мы упомянули ее здесь в качестве примера).
    </p>

    <p>Запись var.Name аналогична записи var[&quot;Name&quot;]:</p>

    <div class="contdiv">
        <pre><code class="lua">
var ::= prefixexp '.' Name
</code></pre>
    </div>

    <p>
        Все глобальные переменные являются полями в обычных таблицах Lua, называемых таблицами окружения или кратко окружениями (см. <a href="#2.9">§2.9</a>). Каждая функция имеет ссылку
        на свое собственное окружение, и все глобальные переменные внутри этой функции ссылаются на данную таблиц. В момент создания функция наследует окружение вызывающей функции. Для получения
        таблицы окружения функции Lua можно вызвать функцию <a href="#pdf-getfenv">getfenv</a>. Для перезаписи таблицы используется <a href="#pdf-setfenv">setfenv</a>.
        (Вы можете манипулировать окружением C&nbsp;функций только с помощью отладочной библиотеки (см. <a href="#5.9">§5.9</a>).)
    </p>

    <p>Обращение к глобальной переменной x эквивалентно _env.x, а также </p>

    <div class="contdiv">
        <pre><code class="lua">
gettable_event(_env, "x")
</code></pre>
    </div>

    <p>
        где _env – окружение выполняющейся функции. (Полное описание функции gettable_event смотрите в <a href="#2.8">§2.8</a>.
        Эта функция недоступна в коде Lua, мы упомянули ее здесь в качестве примера).
    </p>


    <h2><a id="2.4">2.4 – Операторы</a></h2>

    <p>
        В Lua поддерживается стандартный набор операторов, почти как в Pascal или C. Он состоит из операторов присваивания, операторов управления потоком исполнения,
        вызова функций и описания переменных.
    </p>


    <h3><a id="2.4.1">2.4.1 – Порции</a></h3>

    <p>Единица исполнения Lua называется <em>chunk (порция)</em>. Порция – это любая последовательность операторов Lua. Операторы в порции могут разделяться запятыми:</p>

    <div class="contdiv">
        <pre><code class="lua">
chunk ::= {stat [';']}
</code></pre>
    </div>

    <p>Пустого оператора в языке нет, поэтому выражение ';;' не допустимо.</p>

    <p>
        Lua воспринимает порцию как неименованную функцию с произвольным набором параметров (см. <a href="#2.5.9">§2.5.9</a>). Порция может определять локальные
        переменные и возвращать значения.
    </p>

    <p>
        Порция может храниться в файле или в строке базовой программы. В момент запуска порции на выполнение осуществляется компиляция ее в промежуточный
        байт-код (инструкции для виртуальной машины). Затем полученный код исполняется виртуальной машиной.
    </p>


    <h3><a id="2.4.2">2.4.2 – Блоки</a></h3>

    <p>Блок это список операторов; синтаксически блок тождественно равен порции (chunk) :</p>

    <div class="contdiv">
        <pre><code class="lua">
block ::= chunk
</code></pre>
    </div>

    <p>Блок операторов может быть явно ограничен, таким образом представляется составной оператор:</p>

    <div class="contdiv">
        <pre><code class="lua">
stat ::= do block end
</code></pre>
    </div>

    <p>
        С помощью составных операторов можно ограничивать области видимости локальных переменных. Также составные операторы используются в циклах и условном
        операторе (см. <a href="#2.4.4">§2.4.4</a>).
    </p>


    <h3><a id="2.4.3">2.4.3 – Присваивание</a></h3>

    <p>
        Lua поддерживает параллельное присваивание. В общем случае, оператор присваивания выглядит как список переменных, символ ‘=’ и список выражений.
        Элементы списков указываются через запятую:
    </p>

    <div class="contdiv">
        <pre><code class="lua">
	stat ::= varlist1 '=' explist1

	varlist1 ::= var {',' var}

	explist1 ::= exp {',' exp}
</code></pre>
    </div>

    <p>Выражения (exp) рассмотрены в <a href="#2.5">§2.5</a>.</p>

    <p>
        Перед выполнением присваивания список переменных согласовывается по длине со списком выражений. Если список справа длиннее, то его лишние элементы просто отбрасываются.
        Если короче, то недостающие позиции дополняются значениями <b>nil</b>. Если список операторов оканчивается вызовом функции, то перед согласованием все возвращаемые оттуда
        значения вставляются в правый список (за исключением случаев, когда вызов взят в скобки; смотрите <a href="#2.5">§2.5</a>).
    </p>

    <p>Перед выполнением присваивания вычисляется значение всех выражений. Код</p>

    <div class="contdiv">
        <pre><code class="lua">
	i = 3

	i, a[i] = i+1, 20
</code></pre>
    </div>

    <p>
        означает, что переменной a[3] присваивается значение 20, потому что i в выражении a[i] имеет то же самое значение, что и в момент вычисления выражения i+1.
        Аналогично, строка
    </p>

    <div class="contdiv">
        <pre><code class="lua">
	x, y = y, x
</code></pre>
    </div>

    <p>является простым способом обмена значениями двух переменных (при «традиционном» способе требуется дополнительная переменная).</p>

    <p>
        Действие операции присваивания для глобальных переменных и полей таблиц может быть переопределено посредством метатаблиц.
        Присваивание индексной переменной t<span class="S10">[</span>i<span class="S10">]</span> <span class="S10">=</span> val
        эквивалентно вызову settable_event<span class="S10">(</span>t<span class="S10">,</span>i<span class="S10">,</span>val<span class="S10">)</span>.
        (Полное описание функции settable_event смотрите в <a href="#2.8">§2.8</a>. Эта функция недоступна в коде Lua, мы упомянули ее здесь в качестве примера).
    </p>

    <p>Присваивание к глобальной переменной x<span class="S10">=</span>val эквивалентно присваиванию _env.x=val, то же самое произойдет при вызове</p>

    <div class="contdiv">
        <pre><code class="lua">
	settable_event(_env, "x", val)
</code></pre>
    </div>

    <p>где _env окружение запущенной функции. (Переменная _env недоступна в Lua, мы приводим ее здесь в качестве примера. ) </p>


    <h3><a id="2.4.4">2.4.4 – Управляющие конструкции</a></h3>

    <p>Операторы <b>if</b>, <b>while</b>, и <b>repeat</b> имеют обычное значение и знакомый синтаксис:</p>

    <div class="contdiv">
        <pre><code class="lua">
	stat ::= while exp do block end

	stat ::= repeat block until exp

	stat ::= if exp then block {elseif exp then block} [else block] end
</code></pre>
    </div>

    <p>В Lua также имеется выражение <b> for </b>в двух вариантах (см. <a href="#2.4.5">§2.4.5</a>).</p>

    <p>
        Логическое выражение в управляющих конструкциях может возвращать любое значение.
        Значения <b>false</b> и <b>nil</b> считаются ложными. Все остальные значения считаются
        истинными (в том числе значение 0 и пустая строка!).
    </p>

    <p>
        Цикл <b>repeat</b>–<b>until</b> оканчивается условием, идущим следом за <b>until</b>, поэтому
        в условии можно ссылаться на локальные переменные, описанные внутри цикла.
    </p>

    <p>
        Выражение <b>return</b> используется для того, чтобы возвратить значения из функции или
        порции. Синтаксис оператора <b>return</b> позволяет функции или порции вернуть несколько значений:
    </p>

    <div class="contdiv">
        <pre><code class="lua">
	stat ::= return [explist1]
</code></pre>
    </div>

    <p>Оператор <b>break</b> используется для досрочного выхода из циклов <b>while</b>, <b>repeat</b> и <b>for</b>:</p>

    <div class="contdiv">
        <pre><code class="lua">
	stat ::= break
</code></pre>
    </div>

    <p><b>Break</b> прерывает цикл, в теле которого встречается, внешние циклы продолжают выполнение.</p>

    <p>
        <b>Return</b> (или <b>break)</b> должен быть <i>последним</i> оператором в блоке (иначе следующие за ним операторы никогда не выполнятся). Если действительно
        необходимо вставить <b>return</b> или <b>break</b> в середину блока, то следует применить составной оператор, например, do return end и do break end.
    </p>


    <h3><a id="2.4.5">2.4.5 – Оператор For</a></h3>

    <p>Оператор <b>for</b> допускает простую и расширенную формы записи.</p>

    <p>В простой форме <b>for</b> выполняет блок кода до тех пор, пока переменная цикла, изменяеющаяся в арифметической прогрессии, не достигнет установленного порога.</p>

    <div class="contdiv">
        <pre><code class="lua">
	stat ::= for Name ' = ' exp1 ',' exp2 [', ' exp3] do block end
</code></pre>
    </div>

    <p>
        <em>block</em> повторяется для переменной цикла <em>name</em> начиная со значения выражения <em>exp1</em>, до тех пор пока выполняется выражение <em>exp2</em> с
        шагом выражения <em>exp3</em>.
    </p>

    <p>Таким образом, запись </p>

    <div class="contdiv">
        <pre><code class="lua">
	for v = e1, e2, e3 do block end
</code></pre>
    </div>

    <p>эквивалентна коду</p>

    <div class="contdiv">
        <pre><code class="lua">
	do
		local var, limit, step = tonumber(e1), tonumber(e2), tonumber(e3)

		if not (var and limit and step) then error() end

		while (step &gt; 0 and var &lt;= limit) or (step &lt;= 0 and var &gt;= limit) do

			local v = var

			block

			var = var + step
		end
    end
</code></pre>
    </div>

    <p>Обратите внимание, что:</p>

    <ul style="list-style-type:disc" class="contul">
        <li>Все три логических выражения вычисляются только один раз перед началом цикла, причем полученные значения должны быть числами.</li>

        <li><em>var</em>, <em>limit</em>, и <em>step</em> - неявные переменные, мы условно именовали их здесь для объяснения логики работы </li>

        <li>Если выражение step (шаг) отсутствует, то по умолчанию используется 1 </li>

        <li>Для выхода из цикла <b>for</b> используйте <b>break</b>.</li>

        <li>
            Переменная <b>v</b> является локальной для цикла; вы не сможете использовать ее значение после выхода
            из цикла <b>for</b>. Если вам необходимо значение этой переменной, присвойте его другой переменной перед выходом из цикла.
        </li>
    </ul>

    <p>
        Расширенная форма оператора <b>for</b> реализована с использованием функций
        <i>итераторов</i>. На каждом обороте для получения нового значения переменной цикла вызывается <i>итератор</i>.
        Цикл заканчивается, когда <i>итератор </i>вернет <b>nil</b>. Синтаксис расширенного оператора <b>for</b>:
    </p>

    <div class="contdiv">
        <pre><code class="lua">
	stat ::= for namelist in explist1 do block end

	namelist ::= Name {', '~ Name}
</code></pre>
    </div>

    <p>Запись</p>

    <div class="contdiv">
        <pre><code class="lua">
	for var_1, ···, var_n in explist do block end
</code></pre>
    </div>

    <p>можно представить как</p>

    <div class="contdiv">
        <pre><code class="lua">
	do
		local f, s, var = explist

		while true do
			local var_1, ···, var_n = f(s, var)

			var = var_1

			if var == nil then break end

			block
		end
    end
</code></pre>
    </div>

    <p>Заметим, что</p>

    <ul style="list-style-type:disc" class="contul">
        <li><em>explist</em> вычисляется только однажды. Его результатом является функция-<i>итератор, </i>таблица состояний и начальное значение индекса </li>

        <li><em>f</em>, <em>s</em>, и <em>var</em> неявные переменные, именованные здесь для примера </li>

        <li>Выйти из цикла можно с помощью оператора <b>break</b>.</li>

        <li>
            Переменная <em>var</em><em>_</em><em>i</em> является локальной; вы не сможете использовать ее значение после выхода из <b>for</b>. Если вам необходимо ее
            значение, заранее сохраните его в другой переменной.
        </li>
    </ul>


    <h3><a id="2.4.6">2.4.6 – Вызов функции</a></h3>

    <p>Для создания побочных эффектов может быть полезен вызов функций, используемый в качестве оператора:</p>

    <div class="contdiv">
        <pre><code class="lua">
	stat ::= functioncall
</code></pre>
    </div>

    <p>В этом случе все возвращаемые значения отбрасываются. Вызовы функций рассматриваются в <a href="#2.5.8">§2.5.8</a>.</p>


    <h3><a id="2.4.7">2.4.7 – Локальные объявления</a></h3>

    <p>Локальные переменные могут быть объявлены где угодно внутри блока. Объявление может включать инициализацию:</p>

    <div class="contdiv">
        <pre><code class="lua">
	stat ::= local namelist ['=' explist1]
</code></pre>
    </div>

    <p>
        Инициализация обладает всеми свойствами операции присваивания (в том числе параллельностью) (см. <a href="#2.4.3">§2.4.3</a>). По умолчанию все переменные
        инициализируются значением <b>nil</b>.
    </p>

    <p>
        Порция является блоком (см. <a href="#2.4.1">§2.4.1</a>), поэтому локальные переменные могут быть объявлены вне любого явно заданного блока. Областью действия
        таких локальных переменных являются границы порции.
    </p>

    <p>Правила видимости для локальных переменных рассмотрены в <a href="#2.6">§2.6</a>.</p>


    <h2><a id="2.5">2.5 - Выражения</a></h2>

    <p>Выражениями в Lua являются следующие конструкции:</p>

    <div class="contdiv">
        <pre><code class="lua">
	exp ::= prefixexp

	exp ::= nil | false | true

	exp ::= Number

	exp ::= String

	exp ::= function

	exp ::= tableconstructor

	exp ::= '...'

	exp ::= exp binop exp

	exp ::= unop exp

	prefixexp ::= var | functioncall | '(' exp ')'
</code></pre>
    </div>

    <p>
        Числа и символьные строки рассмотрены в <a href="#2.1">§2.1</a>; переменные - в <a href="#2.3">§2.3</a>; описания функций - в <a href="#2.5.9">§2.5.9</a>; вызовы
        функций - в <a href="#2.5.8">§2.5.8</a>; конструкторы таблиц - в <a href="#2.5.7">§2.5.7</a>. Неявные аргументы, обозначаемые ‘...', могут использоваться только внутри
        соответственно заданной функции; смотрите <a href="#2.5.9">§2.5.9</a>.
    </p>

    <p>
        К бинарным операциям (binop в формальном определении выражения) относятся арифметические (см. <a href="#2.5.1">§2.5.1</a>), операции сравнения (<a href="#2.5.2">§2.5.2</a>),
        булевские (<a href="#2.5.3">§2.5.3</a>) и операции конкатенации (смотреть <a href="#2.5.4">§2.5.4</a>). Унарными являются унарный минус (<a href="#2.5.1">§2.5.1</a>),
        отрицание <b>not</b> (<a href="#2.5.3">§2.5.3</a>) и операция получения длины <b>#</b> (<a href="#2.5.5">§2.5.5</a>).
    </p>

    <p>
        Результат вызова функций и неявные параметры могут содержать несколько значений. Если при этом они используются в качестве оператора (<a href="#2.4.6">§2.4.6</a>)
        (только для функций), то все возвращаемые значения отбрасываются. Если это последний (или единственный) элемент в списке выражений, то никакая корректировка не проводится (если вызов не взят
        в скобки). В остальных случаях Lua приводит возвращаемый список к одному элементу, отбрасывая все значения кроме первого.
    </p>

    <p>Далее несколько примеров:</p>

    <div class="contdiv">
        <pre><code class="lua">
	f()                -- результат функции отбрасывается

	g(f(), x)          -- берется первое значение из списка - результата вызова f()

	g(x, f())          -- g получает x и все значения, полученные из f()

	a,b,c = f(), x     -- берется первый элемент результата вызова f()(и c получает nil)

	a,b = ...          -- a получает первый параметр из ..., b - второй (причем а и b могут получить nil, если в качестве неявных параметров ничего не передано)

	a,b,c = x, f()     -- 2 результата из f()

	a,b,c = f()        -- 3 результата из f()

	return f()         -- возвращает все значения из f()

	return ...         -- возвращает все полученные неявные аргументы

	return x,y,f()     -- вернет a, b и все, что вернет f()

	{f()}              -- создаст список со всем результатами вызова f()

	{...}              -- создаст список со всеми неявными параметрами

	{f(), nil}         -- 1 результат из f()
</code></pre>
    </div>

    <p>
        Выражение, заключенное в скобки, всегда возвращает только одно значение. Таким образом,
        <span class="S10">(</span>f<span class="S10">(</span>x<span class="S10">,</span>y<span class="S10">,</span>z<span class="S10">))</span>
        всегда даст единственное значение, даже если f возвращает несколько.
        (Значение <span class="S10">(</span>f<span class="S10">(</span>x<span class="S10">,</span>y<span class="S10">,</span>z<span class="S10">))</span> это первое значение,
        полученное из f, или <span class="S5">nil</span>, если f не возвращает значений.)<br>
    </p>

    <h3><a id="2.5.1">2.5.1 – Арифметические операции</a></h3>

    <p>
        Lua поддерживает обычные арифметические операции: двоичные <span class="S10">+</span> (сложение), <span class="S10">-</span> (вычитание), <span class="S10">*</span> (умножение),
        <span class="S10">/</span> (деление), <span class="S10">%</span> (остаток от деления), и <span class="S10">^</span> (возведение в степень);
        а также унарный минус <span class="S10">-</span> (изменение знака числа). Если операнды являются числами или строками (которые могут быть преобразованы
        в числа <a href="#2.2.1">§2.2.1</a>), то операции выполняются обычным образом. Возведение в степень работает для любого показателя степени. Например, x<span class="S10">^</span>(-0.5) подсчитывает величину, обратную квадратному корню из x.
    </p>


    <h3><a id="2.5.2">2.5.2 – Операции сравнения</a></h3>

    <p>Операции сравнения в Lua:</p>

    <div class="contdiv">
        <pre><code class="lua">
	==    ~=    &lt;     &gt;     &lt;=    &gt;=
</code></pre>
    </div>

    <p>
        Эти операции всегда возвращают <b>false</b>
        или <b>true</b>.
    </p>

    <p>
        Сравнение на равенство (<span class="S10">==</span>)
        сначала сравнивает типы операндов. Если типы различны, то результатом будет <b>false</b>. Иначе сравниваются значения операндов. Числа и строки сравниваются обычным способом. Объекты (таблицы,
        пользовательские данные, потоки и функции) сравниваются по ссылке: два объекта считаются равными, только если они являются одним и тем же объектом. Создаваемый
        объект (таблица, пользовательские данные, поток или функция) не может быть равен ни одному из уже существующих.
    </p>

    <p>
        Правила преобразования из <a href="#2.2.1">§2.2.1</a> <em>НЕ</em> работают в
        сравнениях на равенство. Например, <span class="S6">"0"</span><span class="S10">==</span><span class="S4">0</span>
        вернет <b><span class="S5">false</span></b>, а t<span class="S10">[</span><span class="S4">0</span><span class="S10">]</span> и t<span class="S10">[</span><span class="S6">"0"</span><span class="S10">]</span>&nbsp;обозначают различные
        записи в таблице.
    </p>

    <p>Оператор <span class="S10">~=</span> прямо противоположен оператору равенства (<span class="S10">==</span>).</p>

    <p>
        Операторы сравнения на больше-меньше работают следующим образом. Если оба параметра - числа, то они сравниваются как обычно. Если оба параметра строки,
        то их значения сравниваются в соответствии с лексикографическим порядком. Во всех остальных ситуациях будет вызван метаметод (в данном руководстве не рассматривается).
    </p>


    <h3><a id="2.5.3">2.5.3 – Логические операции</a></h3>

    <p>
        В Lua это операции <b>and (и)</b>, <b>or (или)</b>, и <b>not (не)</b>. Так же, как и в управляющих конструкциях (<a href="#2.4.4">§2.4.4</a>), все логические операции
        рассматривают <b>false</b> и <b>nil</b> как ложь, а все остальное как истину.
    </p>

    <p>
        Операция отрицания <b>not</b> всегда возвращает <b>false</b> или <b> true</b>. Операция конъюнкции <b>and</b> возвращает
        свой первый параметр, если его значение <b> false</b> или <b> nil</b>; в противном случае <b> and</b> возвращает
        второй параметр. Оператор дизъюнкции <b> or</b> возвращает первый параметр, если его значение отлично от <b> nil</b> и <b>false</b>;
        в противном случае <b> or</b> возвращает второй параметр. Оба оператора вычисляют второй операнд только в случае необходимости.
    </p>

    <p>Примеры:</p>

    <div class="contdiv">
        <pre><code class="lua">
    10 or 20            --> 10

    10 or error()       --> 10

    nil or "a"          --> "a"

    nil and 10          --> nil

    false and error()   --> false

    false and nil       --> false

    false or nil        --> nil

    10 and 20           --> 20
</code></pre>
    </div>

    <p>(В данном руководстве, --&gt; указывает на результат выражения.) </p>


    <h3><a id="2.5.4">2.5.4 - Конкатенация</a></h3>

    <p>
        Оператор конкатенации (соединения) строк в Lua обозначается двумя точками ('..').
        Если оба операнда являются строками или числами, то они будут преобразованы в строки согласно правилам <a href="#2.2.1">§2.2.1</a>.
        Иначе будет вызван метаметод (в данном руководстве не рассматривается).
    </p>


    <h3><a id="2.5.5">2.5.5 – Получение длины</a></h3>

    <p>
        Операция получения длины обозначается унарным <b>#</b>. В результате применения операции к строке возвращается количество байт (в обычном понимании
        это длина строки, в которой каждый символ занимает 1 байт).
    </p>

    <p>
        Длиной таблицы t считается любой целый индекс n такой, что t<span class="S10">[</span>n<span class="S10">]</span>
        не равен <span class="S5">nil</span>, а t<span class="S10">[</span>n<span class="S10">+</span><span class="S4">1</span><span class="S10">]</span>
        равно <span class="S5">nil</span>. Кроме того, если t<span class="S10">[</span>
        <span class="S4">1</span><span class="S10">]</span> равен <span class="S5">nil</span>, то
        <span class="S10">#</span>t <span class="S10">=</span> <span class="S4">0</span>. Для регулярных
        массивов от <span class="S4">1</span> до n, не содержащих значений <span class="S5">nil</span>,<span class="S0"> &nbsp;</span>длиной
        является n, то есть индекс последнего значения. Если в массиве присутствуют  <b>"дыры"</b> (т.е., значения <span class="S5">nil</span> между
        ненулевыми значениями), то значением <span class="S10">#</span>t является индекс элемента, непосредственно предшествующего
        элементу <span class="S5">nil</span> (поэтому любое значение <span class="S5">nil</span> по сути означает конец массива).
    </p>


    <h3><a id="2.5.6">2.5.6 – Приоритет операций</a></h3>

    <p>Приоритет операций Lua показан на таблице ниже. Самым высоким приоритетом обладает операция возведения в степень, далее по убыванию:</p>

    <div class="contdiv">
        <pre><code class="lua">
    or
    and
    &lt;     &gt;     &lt;=    &gt;=    ~=    ==
    ..
    +     -
    *     /     %
    not   #     - (unary)
    ^
</code></pre>
    </div>

    <p>
        Как обычно, для изменения порядка вычисления выражений вы можете использовать скобки. Конкатенация ('..') и
        возведение в степень ('^') - правоассоциативные операторы. Все остальные бинарные операторы левоассоциативные.
    </p>


    <h3><a id="2.5.7">2.5.7 – Конструкторы таблиц</a></h3>

    <p>
        Конструкторы таблиц тоже относятся к выражениям. Обработка любого встречающегося в коде конструктора ведет к созданию новой таблицы. С помощью
        конструкторов можно создать как пустые, так и частично либо полностью заполненные таблицы. Полное описание синтаксиса конструкторов:
    </p>

    <div class="contdiv">
        <pre><code class="lua">
    tableconstructor::= '{' [fieldlist] '}'

    fieldlist::= field {fieldsep field} [fieldsep]

    field::= '[' exp ']' '=' exp | Name '=' exp | exp

    fieldsep::= ',' | ';'
</code></pre>
    </div>

    <p>
        Каждое поле вида
        <span class="S10">[</span>exp1<span class="S10">]</span> <span class="S10">=</span>
        exp2 добавляет в новую
        таблицу значение exp2
        с ключом exp1. Поле
        вида name <span class="S10">=</span>
        <span class="S14">exp</span> эквивалентно
        <span class="S10">[</span><span class="S6">"name"</span><span class="S10">]</span>
        <span class="S10">=</span> exp. Поле вида
        <span class="S14">exp</span> эквивалентно
        <span class="S10">[</span>i<span class="S10">]</span> <span class="S10">=</span>
        <span class="S14">exp</span>, где
        i – целочисленный
        автоинкрементный счетчик, начинающийся
        с <span class="S4">1</span>. Поля
        в других форматах не оказывают влияния на этот счетчик. Например,
    </p>

    <div class="contdiv">
        <pre><code class="lua">
	a = { [f(1)] = g; "x", "y"; x = 1, f(x), [30] = 23; 45 }
</code></pre>
    </div>

    <p>эквивалентно </p>

    <div class="contdiv">
        <pre><code class="lua">
	do
		local t = {}

		t[f(1)] = g

		t[1] = "x"

		t[2] = "y"

		t.x = 1

		t[3] = f(x)

		t[30] = 23

		t[4] = 45

		a = t

	end
</code></pre>
    </div>

    <p>
        Если последнее поле в списке задано в форме exp, и exp – это вызов функции или неопределенный
        список параметров, то все значения, возвращаемые этим выражением, последовательно включаются в этот список (<a href="#2.5.8">§2.5.8</a>). Чтобы этого
        избежать, необходимо заключить вызов функции (или список неопределенных параметров) в скобки (<a href="#2.5">§2.5</a>).
    </p>

    <p>Список полей может оканчиваться разделителем, что улучшает читабельность машинно-генерируемого кода.</p>


    <h3><a id="2.5.8">2.5.8 – Вызовы функций</a></h3>

    <p>Вызовы функций в Lua имеют следующий синтаксис:</p>

    <div class="contdiv">
        <pre><code class="lua">
	functioncall ::= prefixexp args
</code></pre>
    </div>

    <p>
        В вызове функции сначала вычисляются префиксное выражение и аргументы. Если
        значение префиксного выражения имеет тип <em>function</em>, то эта функция будет вызвана с указанными
        аргументами. В противном случае вызывается метаметод (в данном руководстве не рассматривается).
    </p>

    <p>Форма записи</p>

    <div class="contdiv">
        <pre><code class="lua">
	functioncall ::= prefixexp ':' Name args
</code></pre>
    </div>

    <p>
        может использоваться для вызова &quot;методов&quot;. Запись v:name
        <span class="S10">(</span>args<span class="S10">)</span> синтаксически
        аналогична записи v.name<span class="S10">
            (
        </span>v<span class="S10">,</span>args<span class="S10">)</span>,
        только v вычисляется
        один раз.
    </p>

    <p>Аргументы описываются следующим образом:</p>

    <div class="contdiv">
        <pre><code class="lua">
	args ::= '(' [explist1] ')'

    args ::= tableconstructor

    args ::= String
</code></pre>
    </div>

    <p>
        Все выражения вычисляются перед вызовом. Вызов в<span class="S0">
        </span>форме f<span class="S10">{</span>fields<span class="S10">}</span><span class="S0">
        </span>синтаксически аналогичен f<span class="S10">
            ({
        </span>fields<span class="S10">})</span>; то
        есть список аргументов<span class="S0"> &nbsp;</span>
        является по сути новой<span class="S0">
        </span>таблицей. Вызов в
        форме f<span class="S7">'string'</span>
        (или f<span class="S6">"string"</span>
        или f<span class="S8">[[string]]</span>) синтаксически
        равен f<span class="S10">(</span><span class="S7">'string'</span>
        <span class="S10">)</span>; в данном случае список аргументов -
        единственная символьная строка.
    </p>

    <p>
        Исключением в довольно свободном синтаксисе Lua является правило, по которому нельзя
        переходить на новую строку непосредственно перед символом '(' в вызове функции. Это ограничение позволяет
        избежать некоторой двусмысленности в языке. Если вы напишите
    </p>

    <div class="contdiv">
        <pre><code class="lua">
	a = f

    (g).x(a)
</code></pre>
    </div>

    <p>
        Lua трактует эту<span class="S0">
        </span>запись как выражение<span class="S0">
        </span>a <span class="S10">=</span> f<span class="S10">
            (
        </span>g<span class="S10">).</span>x<span class="S10">(</span>a<span class="S10">)</span>.
        Поэтому, если вам нужно 2 выражения, вы должны добавить точку с запятой между ними. Если вы действительно хотите
        вызвать f, вы необходимо убрать переход на новую строку перед (g).
    </p>

    <p>
        Вызов в форме return<em> functioncall</em> называется
        <em>концевым вызовом</em>. Lua также поддерживает <em>концевой вызов «себя» </em> (или <i>рекурсивный</i>
        <em>концевой вызов</em>): в этом случае вызванная функция использует стек
        вызывающей функции. Поэтому количество вложенных концевых вызовов может быть
        любым. Заметим только, что концевой вызов стирает отладочную информацию о
        вызывающей функции. Синтаксис концевого вызова допускает только единичный вызов
        функции после оператора <b>return</b>.
        Таким образом, <b>return</b> вернет в точности тот
        результат, что вернет вызов функции. Ни один из представленных ниже примеров не
        является допустимым концевым вызовом:
    </p>

    <div class="contdiv">
        <pre><code class="lua">
    return (f(x))        -- список-результат обрезается

    return 2 * f(x)      -- удвоение результата функции

    return x, f(x)       -- возвращается несколько значений

    f(x); return         -- результат вызова отбрасывается

    return x or f(x)     -- список-результат обрезается
</code></pre>
    </div>


    <h3><a id="2.5.9">2.5.9 – Объявление функций</a></h3>

    <p>Синтаксис объявления функций:</p>

    <div class="contdiv">
        <pre><code class="lua">
    function ::= function funcbody

    funcbody ::= '(' [parlist1] ')' block end
</code></pre>
    </div>

    <p>Или в упрощенном виде</p>

    <div class="contdiv">
        <pre><code class="lua">
    stat ::= function funcname funcbody

    stat ::= local function Name funcbody

    funcname ::= Name {'.' Name} [':' Name]
</code></pre>
    </div>

    <p>Выражение</p>

    <div class="contdiv">
        <pre><code class="lua">
	function f () body end
</code></pre>
    </div>

    <p>транслируется в</p>

    <div class="contdiv">
        <pre><code class="lua">
	f = function () body end
</code></pre>
    </div>

    <p>Выражение</p>

    <div class="contdiv">
        <pre><code class="lua">
	function t.a.b.c.f () body end
</code></pre>
    </div>

    <p>транслируется в</p>

    <div class="contdiv">
        <pre><code class="lua">
	t.a.b.c.f = function () body end
</code></pre>
    </div>

    <p>Выражение</p>

    <div class="contdiv">
        <pre><code class="lua">
	local function f () body end
</code></pre>
    </div>

    <p>транслируется в</p>

    <div class="contdiv">
        <pre><code class="lua">
	local f; f = function () body end
</code></pre>
    </div>

    <p><em>а</em><em> не</em><em> в</em></p>

    <div class="contdiv">
        <pre><code class="lua">
	local f = function () body end
</code></pre>
    </div>

    <p>(Разница проявится в том случае, если в теле функции используется имя этой функции, например при рекурсивном вызове) </p>

    <p>
        Объявление функции является выполняемым выражением, его результатом будет
        значение типа <em>function</em>. Когда Lua прекомпилирует порцию, тела всех упоминающихся в ней функций также прекомпилируются. Таким
        образом, всякий раз, когда Lua обрабатывает объявление функции, функция уже <i>конкретизирована</i> (или <i>замкнута</i>). Этот конкретный экземпляр функции
        (или замыкание) и является конечным значением выражения «объявление функции». Различные
        экземпляры одной и той же функции могу ссылаться на различные внешние локальные переменные и иметь различные таблицы окружения.
    </p>

    <p>Параметры функции фактически являются локальными переменными, которые инициализированы входными значениями:</p>

    <div class="contdiv">
        <pre><code class="lua">
	parlist1 ::= namelist [',' '...'] | '...'
</code></pre>
    </div>

    <p>
        В момент вызова функции длина списка передаваемых параметров приводится в соответствие спецификации, если это не <em>функция</em> с неопределенным
        количеством параметров. Для функций с неопределенным количеством параметров такая коррекция не проводится; все входные параметры попадают в функцию в виде
        <i>неопределенного выражения</i>, которое также обозначается с тремя точками. Значением этого выражения является список всех полученных входных параметров, как в случае
        множественного результата функции. Если <i>неопределенное выражение</i> используется внутри другого выражения или в середине
        списка выражений, то его значение-список урезается до одного элемента. Если это выражение стоит в конце списка выражений, урезания не происходит (если конечно
        вызов не заключен в круглые скобки).
    </p>

    <p>Рассмотрим следующие объявления:</p>

    <div class="contdiv">
        <pre><code class="lua">
    function f(a, b) end

    function g(a, b, ...) end

    function r() return 1,2,3 end
</code></pre>
    </div>

    <p>Пример отображения входных значений на параметры функции:</p>

    <div class="contdiv">
        <pre><code class="lua">
	ВЫЗОВ			ПАРАМЕТРЫ

	f(3)             a=3, b=nil

	f(3, 4)          a=3, b=4

	f(3, 4, 5)       a=3, b=4

	f(r(), 10)       a=1, b=10

	f(r())           a=1, b=2


	g(3)             a=3, b=nil, ... -->  (ничто)

	g(3, 4)          a=3, b=4,   ... -->  (ничто)

	g(3, 4, 5, 8)    a=3, b=4,   ... -->  5  8

	g(5, r())        a=5, b=1,   ... -->  2  3
</code></pre>
    </div>

    <p>
        Результаты возвращаются из функции оператором <b>return</b> (см. <a href="#2.4.4">§2.4.4</a>).
        Если управление достигает конца функции, а оператор <b>return </b>не встретился, то функция завершается
        и ничего не возвращает.
    </p>

    <p>
        <em>Синтаксис с двоеточием <b>‘:’</b></em> используется для определения <em>методов</em>. Эти
        функции неявно получают параметр self в качестве первого аргумента. Таким образом, выражение
    </p>

    <div class="contdiv">
        <pre><code class="lua">
	function t.a.b.c:f (params) body end
</code></pre>
    </div>

    <p>аналогично </p>

    <div class="contdiv">
        <pre><code class="lua">
	t.a.b.c.f = function (self, params) body end
</code></pre>
    </div>



    <h2><a id="2.6">2.6 – Области видимости</a></h2>

    <p>
        Lua язык с лексическим разграничением областей видимости. Область видимости переменной начинается первым выражением <i>после</i> ее
        объявления и действует до конца блока, в котором это объявление встречается. Рассмотрим следующий пример:
    </p>

    <div class="contdiv">
        <pre><code class="lua">
	x = 10                	-- глобальная переменная variable

	do                    	-- начало блока
		local x = x         -- объявление локальной переменной

		print(x)            --> 10

		x = x+1

		do                  -- начало вложенного блока
			local x = x+1   -- другая локальная 'x'

			print(x)        --> 12
		end

		print(x)            --> 11
	end

	print(x)              	--> 10  (глобальная переменная)
</code></pre>
    </div>

    <p>
        Отметим, что в объявлении local x = x локальная переменная объявляется еще не
        в области своей видимости, поэтому присваивается именно внешняя переменная.
    </p>

    <p>
        В соответствии с правилами лексического разграничения областей видимости, локальные
        переменные доступны в функциях, определенных внутри их области видимости. Локальная
        переменная, используемая в таких функциях, называется <i>
            внешней<em>
                локальной переменной
            </em>
        </i><em>(по отношению к определенной</em> внутри ее области видимости функции).
    </p>

    <p>
        Обработка каждого объявления <b>local</b> ведет к созданию новой
        локальной переменной. Рассмотрим следующий пример:
    </p>

    <div class="contdiv">
        <pre><code class="lua">
	a = {}

	local x = 20

	for i=1,10 do

		local y = 0

		a[i] = function () y=y+1; return x+y end

	end
</code></pre>
    </div>

    <p>
        Цикл создает 10 экземпляров функции, в которых используются различные переменные
        y и один и тот же x.
    </p>

    <h2><a id="2.7">2.7 – Обработка ошибок</a></h2>

    <p>
        Поскольку Lua является языком расширений, работа Lua начинается с момента
        вызова в хост-программе функции из Lua-библиотеки (<a href="#lua_pcall">lua_pcall</a>). При
        возникновении ошибки в процессе компиляции или выполнения Lua управление возвращается
        в хост-программу, где и осуществляется ее обработка (например, вывод сообщения о ошибке).
    </p>

    <p>
        Lua-код может явно генерировать ошибку, вызывая функцию <a href="#pdf-error">error</a>.
        Если вам нужно перехватывать ошибки в самом Lua, вы можете использовать функцию <a href="#pdf-pcall">pcall</a>.
    </p>


    <h2><a id="2.8">2.8 – Сборщик мусора</a></h2>

    <p>
        Lua осуществляет автоматическое управление памятью. Это означает, что вам не нужно
        думать о выделении памяти при создании новых объектов и ее освобождении, когда
        объект становится ненужным. Lua время от времени автоматически запускает процедуру <i>
            сборки мусора
        </i>для удаления <i>устаревших объектов</i> (то есть объектов, которые более недоступны из Lua).
        Сборщик мусора обрабатывает все объекты Lua: таблицы, данные типа userdata, функции, потоки и строки.
    </p>



    <h1><a id="3">3 - Использование Lua в программе GEDKeeper</a></h1>

    <h2><a id="3.1">3.1 - Соглашения</a></h2>

    <p>
        Типы данных:<br>
        void - пустой аргумент или результат функции;<br>
        int - целочисленный аргумент или результат функции;<br>
        string - строковый аргумент или результат функции;<br>
        boolean - логический аргумент или результат функции;<br>
    </p>

    <p>
        Внимание:
        Все списки базы данных нумеруются от нуля, поэтому для перебора
        всех записей базы данных следует использовать, к примеру,
        такую конструкцию:
    </p>

    <div class="contdiv">
        <pre><code class="lua">
for i = 0, get_records_count() - 1 do -- т.е. число элементов "-1"
	...
end
</code></pre>
    </div>

    <h2><a id="3.2">3.2 - Структуры данных</a></h2>

    <p>
        Все действия над структурами данных базе выполняются посредством указателей (pointer) на эти структуры.
        Указатель - специальная переменная, указывающая программе на ту или иную структуру в памяти.
    </p>

    <p>
        Указатели на структуры имеют следующие типы:
    </p>
    <ul>
        <li>
            pointer (простой указатель)
            <ul>
                <li>
                    record_pointer (указатель на запись)
                    <ul>
                        <li>individual_pointer (указатель на запись персоны)</li>
                        <li>family_pointer (указатель на запись семьи)</li>
                        <li>note_pointer (указатель на запись заметки)</li>
                        <li>source_pointer (указатель на запись источника)</li>
                        <li>repository_pointer (указатель на запись архив)</li>
                        <li>multimedia_pointer (указатель на запись мультимедиа-объекта)</li>
                        <li>group_pointer (указатель на запись группы)</li>
                        <li>research_pointer (указатель на запись исследования)</li>
                        <li>task_pointer (указатель на запись задачи)</li>
                        <li>commumication_pointer (указатель на запись коммуникаций)</li>
                        <li>location_pointer (указатель на запись места)</li>
                    </ul>
                </li>
            </ul>
        </li>
        <li>
            struct_pointer (указатель на структуру - вложенный объект записи)
            <ul>
                <li>association_pointer (указатель на ассоциацию)</li>
                <li>event_pointer (указатель на событие/факт)</li>
            </ul>
        </li>
    </ul>

    <h2><a id="3.3">3.3 - Функции (API)</a></h2>

    <dl>
        <dt>void print(string text)</dt>
        <dd>вывод строки text;</dd>

        <dt>void progress_init(int length, string title)</dt>
        <dd>показывает окно прогрессии, где length - число этапов прогрессии, title - заголовок;</dd>

        <dt>void progress_done()</dt>
        <dd>скрывает окно прогрессии;</dd>

        <dt>void progress_step()</dt>
        <dd>увеличивает число выполненных этапов прогрессии на один;</dd>

        <dt>int strpos(string substr, string str)</dt>
        <dd>возвращает индекс первого вхождения подстроки substr в строке str;</dd>

        <dt>void update_view()</dt>
        <dd>полностью обновляет вид всех списков (бывает необходимо после массовой обработки данных);</dd>

        <dt>string select_file()</dt>
        <dd>открывает диалог выбора файла и возвращает строку с именем файла</dd>


        <dt>int get_records_count()</dt>
        <dd>возвращает число записей в БД;</dd>

        <dt>record_ptr get_record(int index)</dt>
        <dd>
            возвращает запись базы данных по заданному индексу.
            Внимание: записи различных типов располагаются в БД
            в произвольном порядке - так, как они вводились. Для
            обработки всех записей определенного типа, необходимо
            проверять их тип.
        </dd>

        <dt>int get_record_type(record_ptr)</dt>
        <dd>
            возвращает код - числовую константу, определяющую тип записи;
            возможные варианты:<ul>
                <li>rtNone - тип не определяется либо неизвестен</li>
                <li>rtIndividual - персональная запись</li>
                <li>rtFamily - семья</li>
                <li>rtNote - заметка</li>
                <li>rtMultimedia - мультимедийная запись</li>
                <li>rtSource - запись источника</li>
                <li>rtRepository - архив или хранилище источников</li>
                <li>rtGroup - группа</li>
                <li>rtResearch - исследование</li>
                <li>rtTask - задача</li>
                <li>rtCommunication - коммуникации/переписка</li>
                <li>rtLocation - место</li>
                <li>rtSubmission - [зарезервировано (пока не используется)]</li>
                <li>rtSubmitter - исследователь базы данных</li>
            </ul>
        </dd>

        <dt>string get_record_type_name(int type)</dt>
        <dd>возвращает строку с идентификатором типа записи по его коду.</dd>

        <dt>string get_record_xref(record_ptr)</dt>
        <dd>возвращает строку - идентификатор записи, обеспечивающий перекрестные ссылки между записями в базе</dd>

        <dt>string get_record_uid(record_ptr)</dt>
        <dd>возвращает глобальный уникальный идентификатор записи в базе данных</dd>

        <dt>delete_record(record)</dt>
        <dd>удаляет запись из базы данных</dd>

        <dt>boolean record_is_filtered(record_ptr)</dt>
        <dd>возвращает логический признак, что данная запись отфильтрована и содержится в текущей отображаемой выборке</dd>


        <dt>string get_individual_name(record)</dt>
        <dd>возвращает полное имя персоны.</dd>


        <dt>int get_individual_associations_count(individual_ptr)</dt>
        <dd>возвращает количество ассоциаций заданной персоны.</dd>

        <dt>ptr get_individual_association(individual_ptr, int index)</dt>
        <dd>возвращает ассоциацию заданной персоны по индексу.</dd>

        <dt>delete_individual_association(individual_ptr, index)</dt>
        <dd>удаляет ассоциацию персоны с заданным индексом.</dd>


        <dt>int get_individual_events_count(individual_ptr)</dt>
        <dd>возвращает количество фактов персоны.</dd>

        <dt>event_ptr get_individual_event(individual_ptr, int index)</dt>
        <dd>возвращает заданный индексом факт персоны.</dd>

        <dt>delete_individual_event(individual_ptr, int index)</dt>
        <dd>удаляет заданный индексом факт персоны.</dd>


        <dt>string get_event_value(event_ptr)</dt>
        <dd>возвращает строковое значение факта персоны.</dd>

        <dt>string get_event_place(event_ptr)</dt>
        <dd>возвращает строку места факта персоны.</dd>

        <dt>string get_event_date(event_ptr)</dt>
        <dd>возвращает строковое значение даты факта</dd>

        <dt>string get_event_name(event_ptr)</dt>
        <dd>возвращает строку с именем-идентификатором типа факта (внимание - это внутренние идентификаторы фактов, см. <a href="">Идентификаторы типа факта</a>)</dd>


        <dt>individual_ptr create_individual(string name, string patronymic, string family, string sex)</dt>
        <dd>создает новую персональную запись, где name-имя, patronymic-отчество, family-фамилия, sex-пол (варианты значений: "N"-не задан, "M"-мужской, "F"-женский, "U"-неопределенный)</dd>

        <dt>family_ptr create_family()</dt>
        <dd>создает новую запись семьи</dd>

        <dt>bind_family_spouse(family_ptr family, individual_ptr spouse)</dt>
        <dd>присоединяет супруга "spouse" к семье "family". Внимание: у записи супруга должен быть задан пол, т.к. по нему автоматически определяется роль в семье.</dd>


        <dt>bool csv_load(string filename, bool first_line_is_schema)</dt>
        <dd>загрузить csv-таблицу, первый параметр определяет имя файла, второй - содержит ли первая строка файла заголовки колонок</dd>

        <dt>bool csv_create(string fileName, int columnsCount, int rowsCount)</dt>
        <dd>создать новую csv-таблицу с заданными именем файла, количеством столбцов и строк (обязательно)</dd>

        <dt>csv_close()</dt>
        <dd>закрыть csv-таблицу (чтение или запись)</dd>

        <dt>int csv_get_cols()</dt>
        <dd>получить количество столбцов в csv-таблице</dd>

        <dt>int csv_get_rows()</dt>
        <dd>получить количество строк в csv-таблице</dd>

        <dt>string csv_get_cell(col, row)</dt>
        <dd>получить содержимое ячейки в csv-таблице (столбцы и строки нумеруются от нуля)</dd>

        <dt>void csv_write_cell(string content)</dt>
        <dd>записать значение ячейки CSV-таблицы (переводы строк выполняются автоматически согласно заданному числу столбцов)</dd>


        <dt>note_ptr create_note()</dt>
        <dd>создать новую запись заметки</dd>

        <dt>bind_record_note(record_ptr, note_ptr)</dt>
        <dd>присоединить к записи заметку</dd>

        <dt>add_note_text(note_ptr, string text)</dt>
        <dd>добавляет в запись заметки текстовую строку</dd>

        <dt>record_ptr select_record(int record_type)</dt>
        <dd>вызывает диалог выбора записи из имеющихся</dd>

        <dt>bind_record_source(record_ptr, source_ptr, string page, int quality)</dt>
        <dd>присоединяет к любой записи заданный источник, устанавливает страницу (page) и качество источника (quality, 0..3)</dd>

        <dt>string define_sex(string name, string patronymic)</dt>
        <dd>возвращает идентификатор пола, определенный по имени и отчеству</dd>

        <dt>set_event_place(event_ptr, string place)</dt>
        <dd>установить факту свойство места</dd>

        <dt>source_record create_source(string name)</dt>
        <dd>создает новый источник с заданным названием</dd>

        <dt>source_record find_source(string name)</dt>
        <dd>ищет в списке источник с требуемым названием</dd>

        <dt>event_ptr create_event(record_ptr, string sign)</dt>
        <dd>создать новый факт в записях персон или семей, где sign - строковый тип факта</dd>

        <dt>set_event_date(event_ptr, string date)</dt>
        <dd>установить факту дату</dd>

        <dt>bind_family_child(family_ptr, individual_ptr child)</dt>
        <dd>присоединить к семье ребенка</dd>

        <dt>association_ptr add_individual_association(individual_ptr, string relation, individual_ptr rel_individual)</dt>
        <dd>
            добавяет персоне individual_record, ссылку-ассоциацию на персону rel_individual.
            Используется, к примеру, когда нужно сделать ссылки на крестных.
        </dd>

        <dt>string define_patronymic(string father_name, string child_sex, bool confirm)</dt>
        <dd>
            определяет при помощи встроенного словаря отчество ребенка с полом child_sex по имени отца father_name.
            Параметр confirm(true|false) определяет - спрашивать ли пользователя в сомнительных случаях.
        </dd>

        <dt>family_record get_individual_parents_family(individual_ptr)</dt>
        <dd>возвращает семью родителей данной персоны</dd>

        <dt>int get_individual_spouses_count(individual_ptr)</dt>
        <dd>возвращает число супругов данной персоны</dd>

        <dt>family_ptr get_individual_spouse_family(individual_ptr, int index)</dt>
        <dd>возвращает семью данной персоны и его(её) супруги, index - определяет номер брака</dd>

        <dt>individual_ptr get_family_husband(family_ptr)</dt>
        <dd>возвращает персону мужа данной семьи</dd>

        <dt>individual_ptr get_family_wife(family_ptr)</dt>
        <dd>возвращает персону жены данной семьи</dd>

        <dt>int get_family_childs_count(family_ptr)</dt>
        <dd>возвращает число детей в данной семье</dd>

        <dt>individual_ptr get_family_child(family_ptr, int index)</dt>
        <dd>возвращает персону ребенка заданной семьи по его номеру</dd>
    </dl>

</body>
</html>
