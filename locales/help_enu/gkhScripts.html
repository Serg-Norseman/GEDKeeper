<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8" />
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<title>Scripting</title>
<link rel="stylesheet" href="styles.css" type="text/css" />
</head>
<body>
<h1>Scripting</h1>
<ul>
<li><a href="#1">1 - Introduction to Lua</a></li>
<li><a href="#2">2 – Lua language description</a></li>
<li><a href="#3">3 - Using Lua in GEDKeeper</a></li>
</ul>
<h1><a name="1">1 - Introduction to Lua</a></h1>
<p>Lua is a typical procedural programming language, giving rich
features for development. This is a powerful and simple language with a
huge set of meaningful constructions.</p>
<p>Being a language targeted to extend existing software, Lua
doesn&#39;t use a &quot;main program&quot; concept. Lua operates inside
other programs&#39; environment called <strong>hosts</strong>. In this
case GEDKeeper is the host. A host runs part of the code (next: script)
written in Lua. Because a host can extend the potential of Lua, the latter
may solve a wide range of tasks.</p>
<p>Lua is a freely distributed software, and does not provide any
guarantees when you use it according to Lua license. You can download
<strong>Lua 5.1</strong> described on this page on Lua official site:
<a href="http://www.lua.org" target="_blank">www.lua.org</a>.</p>
<p>As many other manuals, this one has a formal style. To get detailed
technical information about the language usage you should refer to
documentation on the Lua official site. There is a good book about Lua,
that can be helpful for you: it is Roberto Ierusalimschy&#39;s
<em>Programming in Lua, Second Edition</em>.</p>
<h1><a name="2">2 – Lua Language Description</a></h1>
<p>This chapter describes the language&#39;s constructions, how to use them,
and what they mean.
<p>A construction will be presented using extended BNF, where
{<em>a</em>} stands for zero or more number of `<em>a</em>` elements,
and [<em>a</em>] means an optional element. General writing of text is
used for nonterminal symbols, while keywords are highlighted with bold
text: <b>keyword</b>; all other terminal symbols are enclosed in single
quotes: &#39;<b>=</b>&#39;.</p>
<h2><a name="2.1">2.1 – Lexical Conventions</a></h2>
<p><em>Names</em> (<i>identifiers</i>) in Lua is a string of letters,
digits and underline character. It cannot begin with a digit. This is a
typical rule for most programming languages. You use identifiers to name
variables and tables with values.</p>
<p>The following <i>keywords</i> are reserved and cannot be used as
identifiers:</p>
<div class="contdiv">
<pre><code class="lua">and      break    do     else       elseif
end      false    for    function   if
in       local    nil    not        or
repeat   return   then   true       until   while</code></pre>
</div>
<p>Lua is a case-sensitive language: `and` is a keyword, while `And`
and `AND` are two different valid identifiers. There is a convention,
dictating that names beginning with underline and are being written in
upper case (`_VERSION`, for example), are reserved to name Lua&#39;s
internal global variables.</p>
<p>These are another allowed symbols:</p>
<div class="contdiv">
<pre><code class="lua">+    *    &#47;    %    ^    #
==   ~=   &lt;=   &gt;=   &lt;    &gt;    =
(    )    {    }    [    ]
;    :    ,    .    ..   ...</code></pre>
</div>
<p><em>String literals</em> must be enclosed in single or double
quotes, and may contain the following C-like escape sequences:
&#39;\a&#39; (&quot;bell&quot;), &#39;\b&#39; (&quot;backspace&quot;),
&#39;\f&#39; (&quot;page break&quot;), &#39;\n&#39; (&quot;new
line&quot;), &#39;\r&#39; (&quot;carriage return&quot;), &#39;\t&#39;
(&quot;horizontal tab&quot;), &#39;\v&#39; (&quot;vertical tab&quot;),
&#39;\&quot;&#39; (&quot;double quote character&quot;),
&#39;\&#39;&#39; (&quot;single quote character&quot;). When you need to
add a line break into a long line of code, you also use backslash
character. To add a character into string literal using character code,
use the following escape sequence: \<em>ddd</em>, where <em>ddd</em> is
a sequence of maximum three digits. (It is worth noting that when you
need to add a digit after a character written by its code, you have to
use exactly three digits in the escape sequence). Lua strings may
contain any 8-byte value, including the null character which is written as
&#39;\0&#39;.</p>
<p>You have to use escape sequences when you need to add the double quote
character, new line character, backslash, or null character to a string
literal. Any other symbol may be written as-is.</p>
<p>You can also define string literals using long format, when a string
literal is enclosed in <em>long brackets</em>. <em>Opening a long bracket
of level n</em> is defined as an initial square bracket, that follows
equal signs, repeated <em>n</em> times, that follow another initial
square bracket. Thus, opening a long bracket of level&nbsp;0 is written
as `[[`, opening long bracket of level&nbsp;1 is written as `[=[`, and
so on. <em>Closing long bracket</em> is defined in the same way. For
example, closing long bracket of level&nbsp;4 is written as `]====]`.
Long strings begin with opening long bracket of any level, and end with
the first closing bracket of the respective level. Such literals may be
multiline literals; escape sequences inside it never get expanded; long
brackets of any other level are ignored. They may contain anything
except closing bracket of the respective level.</p>
<p>For convenience, when an opening long bracket is followed by new
line character, the latter is not added to the string literal. For
example, on a system, where character &#39;a&#39; is encoded
as&nbsp;97, new line -- as&nbsp;10 and &#39;1&#39; -- as&nbsp;49, the
following five literal declarations are the same:</p>
<div class="contdiv">
<pre>a = &#39;abc\n123&quot;&#39;</pre>
<pre>a = &quot;abc\n123\&quot;&quot;</pre>
<pre>a = &#39;\97bc\10\04923&quot;&#39;</pre>
<pre>a = [[abc
123&quot;]]</pre>
<pre>a = [==[
abc
123&quot;]==]</pre>
</div>
<p><em>Number literal</em> can be written with optional decimal part
and exponent. When you want to define a hexadecimal number, use `0x`
prefix. The following is an example of valid number literals:</p>
<div class="contdiv">
<pre>3   3.0   3.1416   314.16e-2   0.31416E1   0xff   0x56</pre>
</div>
<p>Double hyphen (&#39;--&#39;), everywhere outside a string literal,
begins a <em>comment</em>. When a comment begins with double hyphen and it is
not followed by an opening long bracket [, then the comment is a
<em>short</em> one&#151;it continues until end of the line. Otherwise, this
is a <em>long comment</em>&#151;it continues until a closing long bracket.
Long comment is frequently used to temporary disable a part of
code.</p>
<h2><a name="2.2">2.2 – Types and Values</a></h2>
<p>Lua is a language with <i>dynamic type definition</i>. A variable in
Lua may store values of any type. There is not a method for declaring a
user-defined type. Values in Lua may be stored as a variable, passed as
a function argument, and be a return value of a function.</p>
<p>There are eight main types in Lua: <em>nil</em> (undefined),
<em>boolean</em>, <em>number</em>, <em>string</em>, <em>function</em>,
<em>userdata </em>(user-defined data), <em>thread</em>, and
<em>table</em>. <em>nil</em> is a type of the <b>nil [empty]</b> value.
The main purpose of nil is to differ from other values and designate a
lack of a valid value. Values <b>false</b> and <b>true</b> are of the
<em>boolean</em> type. Both <b>nil</b> and <b>false</b> values are
considered as false values, any other value is true one.
<em>number</em> is type of a double precision floating-point value.
Array of characters are of <em>string</em> type. Strings in Lua may
contain any 8-bit character; this includes the null character &#39;\0&#39;
(see <a href="#2.1">§2.1</a>).</p>
<p>Lua can use a function that was implemented as Lua code, or as a
function that was supplied by host (see <a
href="#2.5.8">§2.5.8</a>).</p>
<p>A <em>userdata</em> (user-defined data) instance stores any data
owned by the host. Values of such an instance reference a memory block.
Only assignment and equality operators are allowed for variables of
type `userdata`. Using <em>metatables</em>, however, a developer can
define operations with variables of this type (see <a
href="#2.8">§2.8</a>). Lua code cannot create or change variables of
`userdata` type, only the host can do that. This guarantees integrity of
data, owned by host.</p>
<p><em>table</em> type defines associative arrays. Both numbers and
other values, except <b>nil</b>, can be used as indices of such arrays.
The table can contain values of several types simultaneously (except
<b>nil</b>). The only way to structure your data in Lua is tables; they
can be used as simple array, character map, set, structure, tree and so
on. To implement a dictionary, Lua uses keys as indices of a table.
Expression `a.name` is equivalent to `a[&quot;name&quot;]` expression.
There are several ways in Lua to create tables (see <a
href="#2.5.7">§2.5.7</a>).</p>
<p>Table&#39;s indices and values can be of any type except <b>nil</b>.
Because functions are also a Lua type, tables can contain
functions. Therefore, tables are able to store <em>methods</em>
(see <a href="#2.5.9">§2.5.9</a>).</p>
<p>Variable of the types <i>table</i>, <i>function</i>,
<i>thread</i>, and <i>userdata</i> never stores a value itself. Such
variable stores a reference to the respective object. Assignment (a
direct one, or passing an argument to a function, or returning a function
result) processes references and never creates object copies.</p>
<p>The <em>type</em> library function returns a string that contains a type
of value.</p>
<h3><a name="2.2.1">2.2.1 – Type Cast</a></h3>
<p>Lua casts string and numeric types on-the-fly automatically. When
you do an arithmetic operation with a string operand, the latter gets
converted to the respective number using general casting types. When
you apply a number where a string is expected, the former gets converted
to the string type in an arbitrary appropriate format. Therefore, when you
need to get some specific string representation of a number, you should
use the <em>format</em> function from the Lua string library (see <a
href="#pdf-string.format">string.format</a>).</p>

<h2><a name="2.3">2.3 - Variables</a></h2>
<p>Variables store values while a program is running. There are three
types of variables in Lua: global variables, local variables, and fields
of tables.</p>
<p>An individual identifier declares a global or local variable (or
function parameter, which is a unique case of a local variable):</p>
<div class="contdiv">
<pre><code class="lua">var ::= Name</code></pre>
</div>
<p>where Name is an identifier defined according to <a
href="#2.1">§2.1</a>.</p>
<p>If a variable was not defined as local explicitly, it is
considered to be a global variable (see <a href="#2.4.7">§2.4.7</a>). A
local variable exists in a lexical context; any function from this
context can access the local variable. (see <a
href="#2.6">§2.6</a>).</p>
<p>All variables are initialized with the <b>nil</b> value by default.</p>
<p>To access a table&#39;s element by its index, you use square
brackets:</p>
<div class="contdiv">
<pre><code class="lua">var ::= prefixexp &#39;[&#39; exp &#39;]&#39;</code></pre>
</div>
<p>You can change access to global variables and fields of tables with the
help of metatables. Expression `t[i]` is equivalent to calling
`gettable_event(t, i)` (a complete description of the `gettable_event`
function is available in <a href="#2.8">§2.8</a>). This function is
unavailable in Lua code and mentioned here only as an example.</p>
<p>`var.Name` expression is equivalent to the `var[&quot;Name&quot;]`
expression:</p>
<div class="contdiv">
<pre><code class="lua">var ::= prefixexp &#39;.&#39; Name</code></pre>
</div>
<p>All global variables are fields of general Lua tables called
environment tables or, compactly, environments (see <a
href="#2.9">§2.9</a>). Each function has a reference to its own
environment and all global variables inside this function refer to
this table. When a function is called, it inherits the environment of the
caller function. You can use the <a href="#pdf-getfenv">getfenv</a>
function to get a function&#39;s environment table, and the <a
href="#pdf-setfenv">setfenv</a> function to change the table (if you
want to change the environment of C&nbsp;functions, you must use the debug
library (see <a href="#5.9">§5.9</a>).</p>
<p>Accessing global variable `x` is equivalent to `_env.x`, or also:</p>
<div class="contdiv">
<pre><code class="lua">gettable_event(_env, &quot;x&quot;)</code></pre>
</div>
<p>where `_env` is the environment of the called function (a complete description
of the `gettable_event` is available in <a href="#2.8">§2.8</a>). This
function is unavailable in Lua code and mentioned here only as an
example.</p>

<h2><a name="2.4">2.4 – Operators</a></h2>
<p>Lua supports a standard operator set, very similar to the ones in Pascal
and C. Lua has an assignment operator, controlling flow of execution,
function call, and defining variables.</p>
<h3><a name="2.4.1">2.4.1 – Chunk</a></h3>
<p><em>Chunk</em> is an execution unit in Lua. Chunk is a sequence of
any Lua operators. Operators in a chunk are delimited by
semicolons:</p>
<div class="contdiv">
<pre><code class="lua">chunk ::= {stat [&#39;;&#39;]}</code></pre>
</div>
<p>Lua does not define &quot;no operator&quot;, therefore `;;`
expression is not allowed.</p>
<p>From Lua&#39;s perspective a chunk is an unnamed function with an
arbitrary parameter set (see <a href="#2.5.9">§2.5.9</a>). Chunk can
define local variables and can return values.</p>
<p>Chunk is stored in file or as a line in base program. When a chunk
is being dispatched to execution, it is compiled to intermediate
bytecode (instructions for virtual machine). Intermediate bytecode then
is executed on the virtual machine.</p>

<h3><a name="2.4.2">2.4.2 – Blocks</a></h3>
<p>Block is an operator list; a block is syntactically equivalent to a
chunk:</p>
<div class="contdiv">
<pre><code class="lua">block ::= chunk</code></pre>
</div>
<p>A block can be defined explicitly, and therefore be a defining compound
operator:</p>
<div class="contdiv">
<pre><code class="lua">stat ::= do block end</code></pre>
</div>
<p>Using compound operators, you can limit the scope for local variables.
Compound operators are also used in loops and with conditional operators (see
<a href="#2.4.4">§2.4.4</a>).</p>

<h3><a name="2.4.3">2.4.3 – Assignment</a></h3>
<p>Lua supports parallel assignment. In the general case, anassignment
operator is variable list; `=` symbol and expression list. List entries
are delimited by a comma:</p>
<div class="contdiv">
<pre><code class="lua">stat ::= varlist1 &#39;=&#39; explist1

varlist1 ::= var {&#39;,&#39; var}

explist1 ::= exp {&#39;,&#39; exp}</code></pre>
</div>
<p>Expressions are discussed in <a href="#2.5">§2.5</a>.</p>
<p>Before been assigned, the variable list is adjusted with an expression list
by their length. If the list on the right side is longer than the one on
the left side then excess elements are simply ignored. If the right list is
shorter then missing elements are defined as <b>nil</b>. If the operator list
ends with function call, then, before adjustment, all return values are
added to the right list (except cases where function call is enclosed
in parentheses; see <a href="#2.5">§2.5</a>).</p>
<p>All expressions are evaluated before assignment. In the following
code:</p>
<div class="contdiv">
<pre><code class="lua">i = 3

i, a[i] = i + 1, 20
</code></pre></div>
<p>`a[3]` gets 20, because `i` in `a[i]` expression has the same value,
as in `i + 1` expression, when it is being evaluated. Similarly, the
following line</p>
<div class="contdiv">
<pre><code class="lua">x, y = y, x</code></pre>
</div>
<p>simply swaps values of two variables (the &quot;classic&quot; method
requires a temporary variable).</p>
<p>Metatables can override assignment operations for global variables
and fields of tables. Assigning to an indexed variable `t[i] = val` is
equivalent to the expression `settable_event(t, i, val)` (a complete
description of the `settable_event` function is available in <a
href="#2.8">§2.8</a>. This function is unavailable in Lua code and
mentioned here only as an example).</p>
<p>Global variable assignment `x = val` is equivalent to `_env.x = val`
expression, or</p>
<div class="contdiv">
<pre><code class="lua">settable_event(_env, &quot;x&quot;, val)</code></pre>
</div>
<p>, where `_env` is environment of called function (variable `_env` is
unavailable in Lua code and mentioned here only as an example).</p>

<h3><a name="2.4.4">2.4.4 – Control Structures</a></h3>
<p><b>if</b>, <b>while</b> and <b>repeat</b> operators have usual
meaning and familiar syntax:</p>
<div class="contdiv">
<pre><code class="lua">stat ::= while exp do block end

stat ::= repeat block until exp

stat ::= if exp then block {elseif exp then block} [else block] end</code></pre>
</div>
<p>There are two variants of a <b>for</b> loop in Lua (see <a
href="#2.4.5">§2.4.5</a>).</p>
<p>A boolean expression in control structures can have any value.
Both <b>false</b> and <b>nil</b> are false values. Everything else is true
(including 0 and an empty string!).</p>
<p>A <b>repeat-until</b> loop ends on the condition that is followed by the
<b>until</b> keyword. Therefore, the loop&#39;s condition can use local
variables from the loop&#39;s scope.</p>
<p>The <b>return</b> operator returns a value from a function or chunk.
Syntax of the <b>return</b> operator allows the return of multiple values from a
function or chunk:</p>
<div class="contdiv">
<pre><code class="lua">stat ::= return [explist1]</code></pre>
</div>
<p>The <b>break</b> operator terminates <b>while</b>, <b>repeat</b>, and
<b>for</b> loops:</p>
<div class="contdiv">
<pre><code class="lua">stat ::= break</code></pre>
</div>
<p><b>break</b> exits a loop, in which scope `break` is written; outer
loops continue execution.</p>
<p><b>return</b> (or <b>break</b>) must be <i>the last</i> operator in
a block (otherwise, all following operators will be ignored). If you do
need to <b>return</b> or <b>break</b> inside a block, you should use a
compound operator; like `do return end` or `do break end`.</p>

<h3><a name="2.4.5">2.4.5 – For Operator</a></h3>
<p>A <b>for</b> operator has a simple and extended notation.</p>
<p>In simple notation <b>for</b> executes code while its loop variable,
that is changed by an arithmetical progression, does not reach a
defined limit.</p>
<div class="contdiv">
<pre><code class="lua">stat ::= for Name &#39; = &#39; exp1 &#39;,&#39; exp2 [&#39;, &#39; exp3] do block end</code></pre>
</div>
<p>The loop repeatedly executes a <em>block</em> for the <em>name</em>
loop variable, that initially has <em>exp1</em> value, increments
<em>name</em> by <em>exp3</em> on each iteration, while <em>exp2</em>
is evaluated to true value.</p>
<p>Thus, the following code</p>
<div class="contdiv">
<pre><code class="lua">for v = e1, e2, e3 do block end</code></pre>
</div>
<p>is equivalent to</p>
<div class="contdiv">
<pre><code class="lua">do
    local var, limit, step = tonumber(e1), tonumber(e2), tonumber(e3)

    if not (var and limit and step) then error() end

    while (step > 0 and var <= limit) or (step <= 0 and var >= limit) do

        local v = var

        block

        var = var + step
    end
end</code></pre>
</div>
<p>It is worth noting that:</p>
<ul type="disc" class="contul">
<li>All three expressions are evaluated once before loop execution.
Result values must be numbers.</li>
<li><em>var</em>, <em>limit</em> and <em>step</em> are implied
variables; we give them names just for convenience, to illustrate loop
logic.</li>
<li>When `step` expression is omitted, step is 1 by default.</li>
<li>To exit from the loop ahead of schedule, use <b>break</b>.</li>
<li><b>v</b> variable is local for the loop. You cannot use its value
after the <b>for</b> loop. If you do need this value, just assign it to
another variable before exit the loop.</li>
</ul>
<p>Extended notation of <b>for</b> operator uses <i>iterator</i>
functions. On each loop iteration iterator is called to get new value
for the loop variable. The loop terminates when its <i>iterator</i>
returns <b>nil</b>. Syntax of extended notation of <b>for</b>
operator:</p>
<div class="contdiv">
<pre><code class="lua">stat ::= for namelist in explist1 do block end

namelist ::= Name {&#39;, &#39;~ Name}</code></pre>
</div>
<p>The following code</p>
<div class="contdiv">
<pre><code class="lua">for var_1, ···, var_n in explist do block end</code></pre>
</div>
<p>can be written as</p>
<div class="contdiv">
<pre><code class="lua">do
    local f, s, var = explist

    while true do
        local var_1, ···, var_n = f(s, var)

        var = var_1

        if var == nil then break end

        block
    end
end</code></pre>
</div>
<p>It is worth noting that:</p>
<ul type="disc" class="contul">
<li><em>explist</em> is evaluated only once. Its result is an
<i>iterator</i> function, state table and initial value for the
index.</li>
<li><em>f</em>, <em>s</em> and <em>var</em> are implied variables; we
give them names just for convenience, to illustrate loop logic.</li>
<li>To exit from the loop ahead of schedule, use <b>break</b>.</li>
<li><i>var_i</i> variable is local for the loop. You cannot use its value
after the <b>for</b> loop. If you do need this value, just assign it to
another variable before exit the loop.</li>
</ul>

<h3><a name="2.4.6">2.4.6 – Function Call</a></h3>
<p>To create a side effect, it may be helpful to call functions, used
as operators:</p>
<div class="contdiv">
<pre><code class="lua">stat ::= functioncall</code></pre>
</div>
<p>In this case all return values are ignored. Function calls are
discussed in <a href="#2.5.8">§2.5.8</a>.</p>

<h3><a name="2.4.7">2.4.7 – Local Declaration</a></h3>
<p>Local variables are declared anywhere inside a block. Declaration
may include initialization:</p>
<div class="contdiv">
<pre><code class="lua">stat ::= local namelist [&#39;=&#39; explist1]</code></pre>
</div>
<p>Initialization has all properties of assignment operation (including
parallelism), see <a href="#2.4.3">§2.4.3</a>. By default, any variable
is initialized with <b>nil</b>.</p>
<p>A chunk is a block (see <a href="#2.4.1">§2.4.1</a>), therefore a
local variable can be declared outside any explicit block. Scope of
such local variable is the chunk&#39;s bounds.</p>
<p>The visibility rules for local variables are discussed in <a
href="#2.6">§2.6</a>.</p>

<h2><a name="2.5">2.5 - Expressions</a></h2>
<p>The following constructs are Lua expressions:</p>
<div class="contdiv">
<pre><code class="lua">exp ::= prefixexp

exp ::= nil | false | true

exp ::= Number

exp ::= String

exp ::= function

exp ::= tableconstructor

exp ::= &#39;...&#39;

exp ::= exp binop exp

exp ::= unop exp

prefixexp ::= var | functioncall | &#39;(&#39; exp &#39;)&#39;</code></pre>
</div>
<p>Numbers and strings are discussed in <a href="#2.1">§2.1</a>;
variables -- in <a href="#2.3">§2.3</a>; function declaration -- in <a
href="#2.5.9">§2.5.9</a>; function call -- in <a
href="#2.5.8">§2.5.8</a>; table constructor -- in <a
href="#2.5.7">§2.5.7</a>. Implicit arguments, that are defined as
`...`, can be used only with the properly declared function; see <a
href="#2.5.9">§2.5.9</a>.</p>
<p>Binary operations (binop) include arithmetic (see <a
href="#2.5.1">§2.5.1</a>), comparison (see <a
href="#2.5.2">§2.5.2</a>), boolean (see <a href="#2.5.3">§2.5.3</a>)
and concatenation (see <a href="#2.5.4">§2.5.4</a>) operations. Unary
operations include unary minus (see <a href="#2.5.1">§2.5.1</a>),
negation <b>not</b> (see <a href="#2.5.3">§2.5.3</a>) and length query
<b>#</b> (see <a href="#2.5.5">§2.5.5</a>).</p>
<p>Function call result and implicit parameters can contain several
values. If they are used as operators (<a href="#2.4.6">§2.4.6</a>)
(functions only), any return value is ignored. If this is the last or
the only element in expression list, no correction is performed (if the
call is not enclosed in parentheses). In all other cases Lua converts
return list to single element by throwing all values away except the
first one.</p>
<p>Here are some examples:</p>
<div class="contdiv">
<pre><code class="lua">f()                -- function result is ignored

g(f(), x)          -- only the first value in the list counts - it is `f()` result

g(x, f())          -- g gets x and all values from f()

a,b,c = f(), x     -- getting the first element from calling to `f()` result (`c` gets `nil`)

a,b = ...          -- `a` gets the first argument from `...`, `b` - the second (both `a` and `b` may get `nil`, when implicit parameter list is empty)

a,b,c = x, f()     -- two results from f()

a,b,c = f()        -- three results from f()

return f()         -- return all values from f()

return ...         -- return all implicit arguments

return x,y,f()     -- return `x`, `y` and everything from f()

{f()}              -- create a list with results from f()

{...}              -- create a list with all implicit parameters

{f(), nil}         -- single result from f()</code></pre>
</div>
<p>An expression enclosed in parentheses always returns single value.
Thus, `(f(x,y,z))` always gives single value, even if `f` returns
several values. Value of `(f(x,y,z))` is the first value that `f`
gives, or `nil` when `f` does not return value.</p>

<h3><a name="2.5.1">2.5.1 – Arithmetic Operations</a></h3>
<p>Lua supports general arithmetic: binary + (addition), -
(subtraction), * (multiplication), &#47; (division), % (remainder in
division) and ^ (powering); unary - (sign reversal of number). When
operands are numbers or strings (which are convertible to numbers <a
href="#2.2.1">§2.2.1</a>), all operations work seamlessly. Powering
functions for any power exponent. For example, x^(-0.5) calculates
reciprocal of square root of `x`.</p>

<h3><a name="2.5.2">2.5.2 – Comparison Operations</a></h3>
<p>The following are Lua&#39;s comparison operations:</p>
<div class="contdiv">
<pre><code class="lua">==    ~=    &lt;     &gt;     &lt;=    &gt;=</code></pre>
</div>
<p>Comparison operations always return <strong>false</strong> or
<strong>true</strong>.</p>
<p>The equality operator (`==`) compares operand types at first. When the
types are different, the operator returns <strong>false</strong>.
Otherwise the operator compares values of operands. Numbers and strings
are compared as usual. Objects (tables, used-defined datatypes, threads
and functions) are compared by reference: two objects are equal when
they are the same object. Newly created object (table, used-defined
datatype, thread or function) cannot be equal to already existing
object.</p>
<p>Conversion rules from <a href="#2.2.1">§2.2.1</a> <em>do not</em>
affect equality operators. For example, `&quot;0&quot;==0` gives
<strong>false</strong>, while `t[0]` and `t[&quot;0&quot;]` are two
different table record.</p>
<p>`~=` operator is antithetic to equality operator `==`.</p>
<p>Lesser or bigger operators works in the following way. Numbers are
compared as usual. Strings are compared in lexicographical order. All
other cases will cause call of metamehod (is not discussed in this
manual).</p>

<h3><a name="2.5.3">2.5.3 – Logical Operations</a></h3>
<p>Lua supports the next logical operations: <strong>and</strong>,
<strong>or</strong> and <strong>not</strong>. Just as control
structures do (<a href="#2.4.4">§2.4.4</a>), logical operations
consider <strong>false</strong> and <strong>nil</strong> as false and
everything else as true.</p>
<p>Negation operation <b>not</b> always returns <b>false</b> or
<b>true</b>. Conjunction operation <b>and</b> returns its first operand
if value of the first operand is <b>false</b> or <b>nil</b>; otherwise
<b>and</b> returns the second operand. Disjunction operation <b>or</b>
returns the first operand when value of the first operand is not equal
to <b>nil</b> and <b>false</b>; otherwise <b>or</b> returns the second
argument. Both operators evaluate the second operand only if it is
necessary.</p>
<p>Examples:</p>
<div class="contdiv">
<pre><code class="lua">10 or 20            --> 10

10 or error()       --> 10

nil or &quot;a&quot;          --> &quot;a&quot;

nil and 10          --> nil

false and error()   --> false

false and nil       --> false

false or nil        --> nil

10 and 20           --> 20</code></pre>
</div>
<p>(In this manual --&gt; shows evaluation results)</p>

<h3><a name="2.5.4">2.5.4 - Concatenation</a></h3>
<p>Strings concatenation operator in Lua is two points: `..`. When both
operands are numbers or strings, they will be converted to strings
according to the rules described in <a href="#2.2.1">§2.2.1</a>.
Otherwise -- metamehod is called (this is not discussed in this
manual).</p>

<h3><a name="2.5.5">2.5.5 – Getting Length</a></h3>
<p>Unary <b>#</b> is getting length operation. This operation returns
number of bytes in a string (in the usual sense, this is the length of
a string where each character occupies one byte).</p>
<p>Any integral index `n` is the length of table `t`, when t[n] is not
nil but t[n+1] is nil. Furthermore, `#t = 0` if t[1] is nil. For arrays
from 1 to n, not containing nils, length is `n`, i.e. index of the last
value. When an array has <b>&quot;holes&quot;</b> (nil values between
non-nil values), `#t` is index of an element, followed by nil value
(therefore, any nil value is the end of array per se).</p>
<h3><a name="2.5.6">2.5.6 – Operator precedence</a></h3>
<p>The following table shows operator precedence in Lua. Powering has
the most priority and then in descending order:</p>
<div class="contdiv">
<pre><code class="lua">or
and
&lt;     &gt;     &lt;=    &gt;=    ~=    ==
..
+     -
*     &#47;     %
not   #     - (unary)
^</code></pre>
</div>
<p>To change expression evaluation order you use parentheses.
Concatenation (&#39;..&#39;) and powering (&#39;^&#39;) are
right-associative operators. All other binary operators are
left-associative.</p>

<h3><a name="2.5.7">2.5.7 – Table constructor</a></h3>
<p>Table constructor is an expression. Any table constructor in code
causes creation of a new table. The constructors can create either
empty or partially or fully initialized tables. This is table
constructor syntax:</p>
<div class="contdiv">
<pre><code class="lua">tableconstructor ::= &#39;{&#39; [fieldlist] &#39;}&#39;

fieldlist ::= field {fieldsep field} [fieldsep]

field ::= &#39;[&#39; exp &#39;]&#39; &#39;=&#39; exp | Name &#39;=&#39; exp | exp

fieldsep ::= &#39;,&#39; | &#39;;&#39;</code></pre>
</div>
<p>Each field, written as `[exp1] = exp2`, adds `exp2` value with
`exp1` key into the table. `name = exp` field is equivalent to
`[&quot;name&quot;] = exp` field. `exp` field is equivalent to [i] =
exp, where `i` is integer autoincrement counter with seed equal to 1.
Fields that were defined in other formats, do not affect this counter.
For example, the following definition:</p>
<div class="contdiv">
<pre><code class="lua">	a = { [f(1)] = g; &quot;x&quot;, &quot;y&quot;; x = 1, f(x), [30] = 23; 45 }</code></pre>
</div>
<p>is equivalent to</p>
<div class="contdiv">
<pre><code class="lua">do
	local t = {}

	t[f(1)] = g

	t[1] = &quot;x&quot;

	t[2] = &quot;y&quot;

	t.x = 1

	t[3] = f(x)

	t[30] = 23

	t[4] = 45

	a = t
end</code></pre>
</div>
<p>If the last field in the definition list was declared as `exp`, and
`exp` is a function call or undefined parameter list, then all values
that are returned by this expression, are sequentially added to this
list (<a href="#2.5.8">§2.5.8</a>). To avoid this, enclose function
call (or undefined parameter list) in parentheses (<a
href="#2.5">§2.5</a>).</p>
<p>Field list may be terminated by delimiter. This makes
computer-generated code more readable.</p>

<h3><a name="2.5.8">2.5.8 – Function Call</a></h3>
<p>Function call in Lua has the following syntax:</p>
<div class="contdiv">
<pre><code class="lua">functioncall ::= prefixexp args</code></pre>
</div>
<p>Prefix expression and arguments are evaluated first in a function
call. When prefix expression has <em>function</em> type, the function
is called with the supplied arguments. Otherwise metamehod is called
(it is not discussed in this manual).</p>
<p>The following notation</p>
<div class="contdiv">
<pre><code class="lua">functioncall ::= prefixexp &#39;:&#39; Name args</code></pre>
</div>
<p>can be used to call &quot;methods&quot; `v:name` expression (args)
is a syntax analog of `v.name` (`v,args`), but `v` is evaluated only
once.</p>
<p>Here is definition on arguments:</p>
<div class="contdiv">
<pre><code class="lua">args ::= &#39;(&#39; [explist1] &#39;)&#39;

args ::= tableconstructor

args ::= String</code></pre>
</div>
<p>All expressions are evaluated before call made. A call made by
`f{fields}` expression is an analog of `f ({fields})` expression; thus,
argument list is a new table per se. A call made by `f&#39;string&#39;`
(or `f&quot;string&quot;`, or `f[[string]]`) is an analog of
`f(&#39;string&#39;)`; but in this case a single string literal is a
list of arguments</p>
<p>Pretty loose Lua syntax has an exception: you cannot add a line
break right before `(` when you call a function. This exception avoids
ambiguity in Lua. If you wrote:</p>
<div class="contdiv">
<pre><code class="lua">a = f

(g).x(a)</code></pre>
</div>
<p>Lua processes this as ` a = f(g).x(a)` expression. If you still need
two expressions, you must add a semicolon between the expressions. If
you actually need to call `f` function, you should remove line break
before `(g)`.</p>
<p>A <em>final call</em> is when you call a function with `return
<em>function call</em>`. Lua supports <em>self final call</em> (or
<em>recursive final call</em>): in this case callee uses stack of the
caller. Therefore number of recursive final calls is not limited. It is
worth noting that a final call removes debug information about the
caller. Syntax of final call allows to call only a single function,
mentioned after <b>return</b> operator. Thus, <b>return</b> gives just
the same result, as the function gives. There is no valid final call in
the following example:</p>
<div class="contdiv">
<pre><code class="lua">return (f(x))        -- result list get truncated

return 2 * f(x)      -- result get doubled

return x, f(x)       -- several values are returned

f(x); return         -- call result is ignored

return x or f(x)     -- result list get truncated</code></pre>
</div>

<h3><a name="2.5.9">2.5.9 – Function Declaration</a></h3>
<p>This is the function declaration syntax:</p>
<div class="contdiv">
<pre><code class="lua">function ::= function funcbody

funcbody ::= &#39;(&#39; [parlist1] &#39;)&#39; block end</code></pre>
</div>
<p>Or, more simplified version:</p>
<div class="contdiv">
<pre><code class="lua">stat ::= function funcname funcbody

stat ::= local function Name funcbody

funcname ::= Name {&#39;.&#39; Name} [&#39;:&#39; Name]</code></pre>
</div>
<p>Expression</p>
<div class="contdiv">
<pre><code class="lua">function f () body end</code></pre>
</div>
<p>is evaluated as</p>
<div class="contdiv">
<pre><code class="lua">f = function () body end</code></pre>
</div>
<p>Expression</p>
<div class="contdiv">
<pre><code class="lua">function t.a.b.c.f () body end</code></pre>
</div>
<p>is evaluated as</p>
<div class="contdiv">
<pre><code class="lua">t.a.b.c.f = function () body end</code></pre>
</div>
<p>Expression</p>
<div class="contdiv">
<pre><code class="lua">local function f () body end</code></pre>
</div>
<p>is evaluated as</p>
<div class="contdiv">
<pre><code class="lua">local f; f = function () body end</code></pre>
</div>
<p><em>but not as</em></p>
<div class="contdiv">
<pre><code class="lua">local f = function () body end</code></pre>
</div>
<p>The difference will appear when function body uses the same function
name, for example, on recursion call.</p>
<p>Function declaration is an evaluated expression, its type is
<em>function</em> type. When Lua is precompiling a chunk, all functions
in the chunk are also precompiled. Thus, when Lua processes a function
declaration, the function is already <i>instantiated</i> (or
<i>closed</i>). This instance (or closure) is the final value of
&quot;function declaration&quot; expression. Different instances of the
same function may refer different outer local variables and have
different environment tables.</p>
<p>Function&#39;s arguments are local variables per se; they are
initialized with argument values:</p>
<div class="contdiv">
<pre><code class="lua">parlist1 ::= namelist [&#39;,&#39; &#39;...&#39;] | &#39;...&#39;</code></pre>
</div>
<p>When a function is called, length of passed argument list is
adjusted according to declaration, if the function is not a
<em>function</em> with variable argument list. There is no adjustment
made for functions with variable argument list; all arguments are
passed as multiple result of function. When <i>an undefined
expression</i> is used inside another expression or inside expression
list, then its value list get truncated to one entry. When such
expression is the last in expression list, truncation is not made (but
only if the call is not enclosed in parentheses).</p>
<p>Let&#39;s examine the following declarations:</p>
<div class="contdiv">
<pre><code class="lua">function f(a, b) end

function g(a, b, ...) end

function r() return 1,2,3 end</code></pre>
</div>
<p>This is an example of how arguments are mapped to function
parameters:</p>
<div class="contdiv">
<pre><code class="lua">CALL            PARAMETERS

f(3)             a=3, b=nil

f(3, 4)          a=3, b=4

f(3, 4, 5)       a=3, b=4

f(r(), 10)       a=1, b=10

f(r())           a=1, b=2


g(3)             a=3, b=nil, ... --&gt;  (nothing)

g(3, 4)          a=3, b=4,   ... --&gt;  (nothing)

g(3, 4, 5, 8)    a=3, b=4,   ... --&gt;  5  8

g(5, r())        a=5, b=1,   ... --&gt;  2  3</code></pre>
</div>
<p>A function gives back its result with <b>return</b> operator (see <a
href="#2.4.4">§2.4.4</a>). If you omitted <b>return</b> operator, and
execution flow reaches end of the function, function completes but do
not return any value.</p>
<p><em>Syntax with a colon (<b>`:`</b>)</em> is used when you need to
define <em>methods</em>. Such functions get `self` as implicit first
argument. Thus, expression:</p>
<div class="contdiv">
<pre><code class="lua">function t.a.b.c:f (params) body end</code></pre>
</div>
<p>is similar to:</p>
<div class="contdiv">
<pre><code class="lua">t.a.b.c.f = function (self, params) body end</code></pre>
</div>

<h2><a name="2.6">2.6 – Scope</a></h2>
<p>Lua is a language having lexical delimitation of scopes. A variable
scope begins <i>after</i> the variable declaration and exists until end
of block, where the variable was declared. Let&#39;s examine the
following example:</p>
<div class="contdiv">
<pre><code class="lua">x = 10                  -- a global variable

do                      -- beginning of a block
    local x = x         -- local variable declaration

    print(x)            --&gt; 10

    x = x+1

    do                  -- beginning of an enclosed block
        local x = x+1   -- another local variable &#39;x&#39;

        print(x)        --&gt; 12
    end

    print(x)            --&gt; 11
end

print(x)                --&gt; 10  (global variable)</code></pre>
</div>
<p>It is worth noting that in the `local x = x` declaration, the local
variable is declared in foreigner scope, therefore value of the
external variable is assigned.</p>
<p>According to the rules of lexical delimitation of scopes, local
variables are accessible for functions, that were declared in
variables&#39; scopes. When such a function uses such a variable, the
variable is called <em>outer local variable</em> (relative to a function
declared in the variable&#39;s scope).</p>
<p>Each <b>local</b> declaration creates new local variable. For
example:</p>
<div class="contdiv">
<pre><code class="lua">a = {}

local x = 20

for i=1,10 do

    local y = 0

    a[i] = function () y=y+1; return x+y end

end</code></pre>
</div>
<p>The loop creates ten instances of the function, which use different
`y` variables and the same `x` variable.</p>

<h2><a name="2.7">2.7 – Error Handling</a></h2>
<p>Lua is an extension language, therefore, Lua starts to work  when a
hosting code has called <a href="#lua_pcall">lua_pcall</a> Lua library
function. If an error occurred while Lua code was being compiled or
run, host application gets execution control and performs error
handling (it shows an error message, for example)</p>
<p>Lua program can generate an error explicitly, by calling <a
href="#pdf-error">error</a> function. If you want to handle errors in
Lua code itself, use <a href="#pdf-pcall">pcall</a> function.</p>

<h2><a name="2.8">2.8 – Garbage Collector</a></h2>
<p>Lua manages memory resources automatically. This means that you do
not have to worry about memory allocation when you create an object,
and memory deallocation once an object becomes unnecessary. Lua runs a
<i>garbage collector</i> periodically that removes in background
<i>out of date objects</i> (i.e. objects that are not accessible from
Lua code anymore). The garbage collector processes all Lua objects:
tables, userdata instances, functions, threads, and strings.</p>

<h1><a name="3">3 - Using Lua in GEDKeeper</a></h1>

<h2><a name="3.1">3.1 - Naming Convention</a></h2>
<p>&quot;gk_&quot; prefix is used for general functions,<br />
&quot;gt_&quot; prefix is used for functions that process a tree.</p>
<p>Data types:<br />
`void` is an empty argument or function result;<br />
`int` is an integer argument or function result;<br />
`string` is a string argument or function result;<br />
`boolean` is a boolean argument or function result.</p>
<p>Attention: the first entry in any database list has zero index.
Therefore, to enumerate all database records, for example, you should
use the following code:</p>

<div class="contdiv"><pre><code class="lua">
for i = 0, gt_get_records_count() - 1 do -- i.e. number of elements &quot;-1&quot
	...
end</code></pre>
</div>

<h2><a name="3.2">3.2 - Data Structure</a></h2>
<p>Any database structure is handled via pointers. A pointer is a
special variable that stores (refers to) some memory location where a
structure is located.</p>
<p>The following are available types of pointer to structures:</p>
<ul>
<li>pointer (a general pointer)</li>
<ul>
<li>record_pointer (pointer to a record)</li>
<ul>
<li>person_pointer (pointer to a person record)</li>
<li>family_pointer (pointer to a family record)</li>
<li>note_pointer (pointer to a note record)</li>
<li>source_pointer (pointer to a source record)</li>
<li>repository_pointer (pointer to an archive record)</li>
<li>multimedia_pointer (pointer to a multimedia-object record)</li>
<li>group_pointer (pointer to a group record)</li>
<li>research_pointer (pointer to a research record)</li>
<li>task_pointer (pointer to a task record)</li>
<li>commumication_pointer (pointer to a correspondence record)</li>
<li>location_pointer (pointer to a location record)</li>
</ul>
</ul>
<li>struct_pointer (pointer to a structure as an object embedded into a
record)</li>
<ul>
<li>association_pointer (pointer to an association)</li>
<li>event_pointer (pointer to an event&#47;fact)</li>
</ul>
</ul>

<h2><a name="3.3">3.3 - API</a></h2>
<dl>
<dt>void gk_print(string text)</dt>
<dd>Outputs `text` string.</dd>
<dt>void gk_progress_init(int length, string title)</dt>
<dd>Shows the window with a progress state, where `length` is number of
progress stages, `title` is a header.</dd>
<dt>void gk_progress_done()</dt>
<dd>Hides the window with a progress state.</dd>
<dt>void gk_progress_step()</dt>
<dd>Increases number of completed progress stages by one.</dd>
<dt>int gk_strpos(string substr, string str)</dt>
<dd>Finds the first occurrence of `substr` in `str` and returns its
index.</dd>
<dt>void gk_update_view()</dt>
<dd>Updates all lists (this is necessary after bulk update).</dd>
<dt>string gk_select_file()</dt>
<dd>Shows &quot;Open file&quot; dialog and returns filename.</dd>
<dt>int gt_get_records_count()</dt>
<dd>Returns number of records in database.</dd>
<dt>record_ptr gt_get_record(int index)</dt>
<dd>Gets a database record by its index. Attention: records of all type
are located randomly in database. They are stored in a sequence in
which they were added to database. Therefore, you should always check
type of a record.</dd>
<dt>int gt_get_record_type(record_ptr)</dt>
<dd>Gets type of the specified record. Possible return values:</dd>
<ul>
<li>rtNone - is is unable to determine type of the record or the record
has unknown type,</li>
<li>rtIndividual - person record,</li>
<li>rtFamily - family record,</li>
<li>rtNote - note record,</li>
<li>rtMultimedia - multimedia content record,</li>
<li>rtSource - source record,</li>
<li>rtRepository - archive or storage of sources record,</li>
<li>rtGroup - group record,</li>
<li>rtResearch - research record,</li>
<li>rtTask - task record,</li>
<li>rtCommunication - correspondence record,</li>
<li>rtLocation - location record,</li>
<li>rtSubmission - [reserved for future use],</li>
<li>rtSubmitter - database researcher.</li>
</ul>
<dt>string gt_get_record_type_name(int type)</dt>
<dd>Converts record type from numeric view to string one.</dd>
<dt>string gt_get_record_xref(record_ptr)</dt>
<dd>Returns record identifier, used for cross-reference links between
database records.</dd>
<dt>string gt_get_record_uid(record_ptr)</dt>
<dd>Get global unique identifier of the specified record.</dd>
<dt>gt_delete_record(record)</dt>
<dd>Removes the specified record from database.</dd>
<dt>boolean gt_record_is_filtered(record_ptr)</dt>
<dd>Returns `true` when the specified record was filtered out and it is
visible on the current view.</dd>
<dt>string gt_get_person_name(record)</dt>
<dd>Gets full name of the specified person.</dd>
<dt>int gt_get_person_associations_count(person_ptr)</dt>
<dd>Gets number of associations for the specified person.</dd>
<dt>ptr gt_get_person_association(person_ptr, int index)</dt>
<dd>Gets an association for specified person by the given index.</dd>
<dt>gt_delete_person_association(person_ptr, index)</dt>
<dd>Removes the specified association from the specified person.</dd>
<dt>int gt_get_person_events_count(person_ptr)</dt>
<dd>Gets number of facts for the specified person.</dd>
<dt>event_ptr gt_get_person_event(person_ptr, int index)</dt>
<dd>Get a fact for the specified person using the specified index.</dd>
<dt>gt_delete_person_event(person_ptr, int index)</dt>
<dd>Removes the specified fact from the specified person.</dd>
<dt>string gt_get_event_value(event_ptr)</dt>
<dd>Converts the specified event to a string.</dd>
<dt>string gt_get_event_place(event_ptr)</dt>
<dd>Gets location of the specified event.</dd>
<dt>string gt_get_event_date(event_ptr)</dt>
<dd>Gets date of the specified event as a string.</dd>
<dt>string gt_get_event_name(event_ptr)</dt>
<dd>Returns name - identifier of the specified event type (attention:
this is internal event identifier, see <a href="">Identifiers of event
types</a>).</dd>
<dt>person_ptr gt_create_person(string name, string patronymic, string
family, string sex)</dt>
<dd>Creates new person record: `name` is person&#39;s first name,
`patronymic` is person&#39;s patronymic name, `family` is person&#39;s
last name, `sex` is person sex (possible values: &quot;N&quot; -- not
defined, &quot;M&quot; -- male, &quot;F&quot; -- female, &quot;U&quot;
-- unknown).</dd>
<dt>family_ptr gt_create_family()</dt>
<dd>Creates new family record.</dd>
<dt>gt_bind_family_spouse(family_ptr family, person_ptr spouse)</dt>
<dd>Attaches `spouse` husband to `family`. Attention: `spouse` record
must have defined sex, because it is used on automatic detection of a
role in family.</dd>
<dt>bool csv_load(string filename, bool first_line_is_schema)</dt>
<dd>Loads CSV table from `filename` file. `first_line_is_schema`
defines whether the first row in the file is a header row.</dd>
<dt>csv_close()</dt>
<dd>Close previously opened CSV table.</dd>
<dt>int csv_get_cols()</dt>
<dd>Returns number of columns in the CSV table.</dd>
<dt>int csv_get_rows()</dt>
<dd>Returns number of rows in the CSV table.</dd>
<dt>string csv_get_cell(col, row)</dt>
<dd>Gets value of the specified cell in the CSV table (rows and columns
are numbered from zero).</dd>
<dt>note_ptr gt_create_note()</dt>
<dd>Creates new note record.</dd>
<dt>gt_bind_record_note(record_ptr, note_ptr)</dt>
<dd>Attaches the note to the record.</dd>
<dt>gt_add_note_text(note_ptr, string text)</dt>
<dd>Appends the specified note with the new `text`.</dd>
<dt>record_ptr gt_select_record(int record_type)</dt>
<dd>Shows record selection dialog.</dd>
<dt>gt_bind_record_source(record_ptr, source_ptr, string page, int
quality)</dt>
<dd>Attaches the specified source to the specified record and sets
`page` and source `quality` (0..3).</dd>
<dt>string gt_define_sex(string name, string patronymic)</dt>
<dd>Returns sex identifier evaluated from `name` and `patronymic`.</dd>
<dt>gt_set_event_place(event_ptr, string place)</dt>
<dd>Sets location in the specified event.</dd>
<dt>source_record gt_create_source(string name)</dt>
<dd>Creates new source with the specified name.</dd>
<dt>source_record gt_find_source(string name)</dt>
<dd>Search through list for a source with the specified name.</dd>
<dt>event_ptr gt_create_event(record_ptr, string sign)</dt>
<dd>Creates new fact in person or family record, where `sign` is type
of the fact given by string.</dd>
<dt>gt_set_event_date(event_ptr, string date)</dt>
<dd>Sets `date` for the specified event.</dd>
<dt>gt_bind_family_child(family_ptr, person_ptr child)</dt>
<dd>Adds the specified child to the specified family.</dd>
<dt>association_ptr gt_add_person_association(person_ptr, string
relation, person_ptr rel_person)</dt>
<dd>Adds to `person_record` new link-association to `rel_person`. For
example, this can be used when one creates a link with godparents.</dd>
<dt>string gt_define_patronymic(string father_name, string child_sex,
bool confirm)</dt>
<dd>Defines patronymic name of a child that is `child_sex` and having
father with `father_name`, using internal dictionary. `confirm`
parameter defines must a confirmation be shown to user in arguable
cases.</dd>
<dt>family_record gt_get_person_parents_family(person_ptr)</dt>
<dd>Gets parent&#39;s family of the specified person.</dd>
<dt>int gt_get_person_spouses_count(person_ptr)</dt>
<dd>Gets number of spouses of the specified person.</dd>
<dt>family_ptr gt_get_person_spouse_family(person_ptr, int index)</dt>
<dd>Gets family of the specified person and his wife or her husband,
`index` is a marriage number.</dd>
<dt>person_ptr gt_get_family_husband(family_ptr)</dt>
<dd>Gets husband in the specified family.</dd>
<dt>person_ptr gt_get_family_wife(family_ptr)</dt>
<dd>Gets wife in the specified family.</dd>
<dt>int gt_get_family_childs_count(family_ptr)</dt>
<dd>Gets number of children in the specified family.</dd>
<dt>person_ptr gt_get_family_child(family_ptr, int index)</dt>
<dd>Gets a child person in the specified family by child number.</dd>
</dl>
</body>
</html>
